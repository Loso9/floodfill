<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title> Ako tečie voda </title>
	<link rel="icon" href="icons/water.png" type="image/png">
	<link href="style.css" rel="stylesheet" />
</head>
<body>

<!-- V headeri sa nachadza primarne button o informaciach o projekte -->
<header>
	<!-- Button "Informacie" -->
	<div class="button-wrapper">
		<button type="button" class="button" title="Informácie o stránke" id="openModal"> 
			<img src="icons/information.png" class="icon" width="50px" height="50px"> 
		</button>
		<span class="label" id="infoLabel"> Informácie </span>
	</div>
	
	<!-- Popup okno, ktore sa otvori po kliknuti na Button "Informacie" -->
	<div class="modal" id="modal">
			<div class="modal-inner">
				
				<!-- Button Zatvor Popup -->
				<div class="button-wrapper">
					<button type="button" class="button" title="Informácie o stránke" id="closeModal"> 
						<img src="icons/close.png" class="icon" width="25px" height="25px"> 
					</button>
				</div>
				
				<!-- Text popupu -->
				<h2> Projekt - Ako tečie voda </h2>
				<p> 
				Projekt <i>Ako tečie voda </i> je inšpirovaný algoritmom <b>FloodFill</b>. V tomto softvéri má užívateľ k dispozícií dva 
				režijné módy - hra a tvorba. V režime "hra" má používateľ možnosť riešiť úlohy na mriežke, týkajúce sa spomínaného algoritmu.
				Vzhľadom na zadanie môže používateľ v móde <i> Experimentuj </i> (ikona pera) pridávať prekážky; určovať, odkiaľ sa má 
				začať liať voda; označovať štvorčeky, kam sa, podľa neho, voda nedostane; prípadne do štvorčekov vkladať čísla určujúce 
				poradie zaplavenia vodou. 
				</p>
				<div id="linkSpecifikacia">
					<a href="specs.pdf"> Špecifikácia projektu </a>
				</div>
			</div>
		</div>
</header>

<!-- Nadpisy -->
<h1> Ako tečie voda</h1>
<h2> Marek Lošonský, Martin Hošek </h2>

<!-- Div na rezimy hry -->
<div class="mode-switch">
	<span id="mode-hra" class="active"> HRA </span>
	<span id="mode-tvorba"> TVORBA </span>
</div>


<!-- Seria Buttonov pre herny rezim -->
<div id="hra-buttony">
	<div class="button-bar">
		<!-- zatial nevyuzity button Zadanie 
		<div class="button-wrapper">
			<button type="button" class="button" title="Zobraz zadanie"> 
				<img src="icons/quest.png" class="icon" width="40px" height="40px"> 
			</button>
			<span class="label" id="zadanieLabel"> Zadanie </span>
		</div> 
		-->
		<div class="button-wrapper" id="freeButtonDiv">
			<button type="button" class="button" id="freeButton"> 
				<img src="icons/free.png" class="icon" width="50px" height="50px"> 
			</button>
			<!-- neviditelny input element pre filepicker -->
			<input type="file" multiple id="fileInput" accept=".json" style="display: none;"/>
			<span class="label" id="freeLabel"> Voľný režim </span>
		</div>
		<div class="button-wrapper" id="loadButtonDiv">
			<button type="button" class="button" id="loadButton"> 
				<img src="icons/load.png" class="icon" width="50px" height="50px"> 
			</button>
			<!-- neviditelny input element pre filepicker -->
			<input type="file" multiple id="fileInput" accept=".json" style="display: none;"/>
			<span class="label" id="loadLabel"> Načítaj úlohy </span>
		</div>
		<div class="button-wrapper" id="upravButtonDiv">
			<button type="button" class="button" id="upravButton"> 
				<img src="icons/pen.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="upravLabel"> Uprav mriežku </span>
		</div>
		<div class="button-wrapper" id="nextStepButtonDiv">
			<button type="button" class="button" id="nextStepButton"> 
				<img src="icons/one.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="nextStepLabel"> Spusti jeden krok </span>
		</div>
		<div class="button-wrapper" id="runButtonDiv">
			<button type="button" class="button" id="runButton">
				<img src="icons/play-button.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="runLabel"> Spusti program </span>
		</div>
		<div class="button-wrapper">
			<button type="button" class="button" id="saveButton">
				<img src="icons/save.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="ulozLabel"> Ulož riešenie </span>
		</div>
		<div class="button-wrapper">
			<button type="button" class="button" id="nextButton">
				<img src="icons/arrow.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="dalejLabel"> Ďalšia úloha </span>
		</div>
	</div>
</div>


<!-- Div v ktorom bude jednak mriezka (vlavo) a zadanie (vpravo), !!! a extra buttony podla zadania vlavo -->
<div id="hra-section">
	<div id="task-wrapper">
		<div id="levelCounter">
			<p> Voľný režim </p>
		</div>
		<h3 id="zadanieHeader"> </h3>
		<div id="task">
			<p> 
			Aktuálne sa nachádzate vo voľnom režime, v ktorom môžete do mriežky pridávať <u>prekážky</u> a <u>zdroje vody</u>. 
			Pre načítanie zadaní úloh kliknite na tlačítko <b>Načítaj úlohy</b>.
			</p>
		</div>
		<div id="solution"> </div> 
	</div>
	<div id="sidebar-grid">
		<div id="grid"> </div>
		<div id="sidebar">
			<div id="sidebar-top">
				<span class="label" id="helperLabel"> Nástroje </span>
				<div class="sidebar-button-wrapper" id="cleanButtonDiv">
					<button type="button" class="button" id="cleanButton"> 
						<img src="icons/clean.png" class="icon" width="40px" height="40px">
					</button>
					<span class="label" id="cleanLabel"> Vyčisti mriežku </span>
				</div>
				<div class="sidebar-button-wrapper" id="cleanWaterButtonDiv">
					<button type="button" class="button" id="cleanWaterButton"> 
						<img src="icons/delete-water.png" class="icon" width="40px" height="40px">
					</button>
					<span class="label" id="cleanWaterLabel"> Odstráň vodu </span>
				</div>
				<div class="sidebar-button-wrapper" id="cleanObstaclesButtonDiv">
					<button type="button" class="button" id="cleanObstaclesButton"> 
						<img src="icons/delete-obstacles.png" class="icon" width="40px" height="40px">
					</button>
					<span class="label" id="cleanObstaclesLabel"> Odstráň prekážky </span>
				</div>
			</div>
			<!-- v spodnom sidebare nebudu buttony, ale iba ikony -->
			<div id="sidebar-bottom">
				<span class="label" id="helperLabel"> Pomôcka </span>
				<div class="sidebar-icon-wrapper">
					<img src="icons/left-click.png" class="icon" width="40px" height="40px">
					<span class="label" id="leftClickLabel"> Pridaj vodu </span>
				</div>
				<div class="sidebar-icon-wrapper">
					<img src="icons/right-click.png" class="icon" width="40px" height="40px">
				 	<span class="label" id="rightClickLabel"> Pridaj prekážku </span>
				</div>
			</div>
		</div>
	</div>
</div>

<!-- CAST 2 - MOD TVORBA TODO -->
<div id="tvorba-section"> </div>

<!-- Päta stranky -->
<footer>
	<p> Softvér pre vzdelávanie, 1mAIN, 2025/2026
</footer>

<script>
	const modeHra = document.getElementById("mode-hra");
	const modeTvorba = document.getElementById("mode-tvorba");
	const hraSection = document.getElementById("hra-section");
	const tvorbaSection = document.getElementById("tvorba-section");
	const loadButton = document.getElementById("loadButton");
	const fileInput = document.getElementById("fileInput");
	const nextButton = document.getElementById("nextButton");
	
	//pomocne pole kde si budeme ukladat zadania
	let assignments = [];
	//defaultne je volny rozim (ziadne zadanie)
	let assignmentIndex = 0;
	
	let currentAssignment;
	
	let gridArray = []; // 2D pole reprezentujuce mriezku
	let waterCells = []; //bunky obsahujuce vodu
	let obstacleCells = []; //bunky obsahujuce prekazku

	//na zaciatku programu je volny mod, ked moze uzivatel pridavat prekazky a pridavat vodu a skusat, ako funguje algoritmus
	let assignmentType = "free";
	
	// Inicializacia 2D pola na zaklade poctu riadkov a stlpcov
	function initializeGridArray(rows, cols) {
		// 0 znamena prazdne policko v array reprezentacii
		gridArray = Array.from({ length: rows }, () => Array(cols).fill(0));
		// console.log(gridArray); // Pre kontrolu vypis do konzoly
	}

	function updateCounter() {
		const counter = document.getElementById("levelCounter");
		
		//ak mam len jedno zadanie, tak napise do div len "Uloha"
		if (assignments.length === 1) {
			counter.innerText = "Úloha";
		}
		else if (assignments.length > 1) {
			//updatni counter vo forme Uloha M/N, kde M je aktualne cislo ulohy a N je pocet vsetkych nacitanych uloh
			counter.innerText = "Úloha " + (assignmentIndex + 1) + "/" + assignments.length;
		}
		else {
			//nic nebolo nacitane
			counter.innerText = "";
		}
	}
	
	function showAssignment(index) {
	
		currentAssignment = assignments[index];

		assignmentIndex = index;
		assignmentType = currentAssignment.type;

		//console.log("Vykonalo sa1");
		
		//ak nemam zadanie, tak nic nerob
		if (!currentAssignment) return;
		
		let assignmentText = currentAssignment.text;
		
		//console.log("Vykonalo sa2");

		//formatovanie zadania
		assignmentText = assignmentText.replaceAll("{{target}}", `<u>${currentAssignment.targetWord}</u>`);
		document.getElementById("task").innerHTML = assignmentText;

		//console.log("Vykonalo sa3");

		//nacitaj do interneho pola stav mriezky z JSONu
		gridArray = currentAssignment.grid.gridState;

		//console.log(gridArray);

		//nacitaj do mriezky na stranke stav mriezky z JSONu
		for (let row = 0; row < gridArray.length; row++) {
			for (let col = 0; col < gridArray[row].length; col++) {
				let cellId = `cell-${row}-${col}`;
				let cell = document.getElementById(cellId);
				//ak je bunka prazdna
				if (gridArray[row][col] === 0) {
					cell.className = "cell cellEmpty";
				}
				//ak je v bunke voda
				else if (gridArray[row][col] === 1) {
					cell.className = "cell cellWater";
				}
				//ak je v bunke prekazka
				else if (gridArray[row][col] === 2) {
					cell.className = "cell cellObstacle";
				}
				//moznost doplnit o dalsie moznosti 
			}
		}
		
		// TODO nacitanie 
		//ak je assignment typu 
		//if (currentAssignment.type === "avoid_cells")
		
		document.getElementById("zadanieHeader").innerText = "Zadanie";
		//zvys counter Uloha (nad textom zadania)
		updateCounter();
	
	}
	
	//funkcia na ukladanie aktualnej session do jsonu 
	function getSessionData() {
		//ulozenie stavu mriezky 
		const gridState = gridArray;
		
		//vrat objekt typu "avoid_cells" (vo formate, ako je json)
		if (currentAssignment.type === "avoid_cells") {
			return {
				type: currentAssignment.type,
				text: currentAssignment.text,
				targetWord: currentAssignment.targetWord,
				grid: {
					rows: currentAssignment.grid.rows,
					cols: currentAssignment.grid.cols,
					gridState
				},
				goal: {
					numOfEmptyCells: currentAssignment.numOfEmptyCells,
					minNumOfObstacles: currentAssignment.minNumOfObstacles
				} 
			};
		}
		//vrat objekt typu "fastest_fill"
		else if (currentAssignment.type === "fastest_fill") {
			return {
				type: currentAssignment.type,
				text: currentAssignment.text,
				targetWord: currentAssignment.targetWord,
				grid: {
					rows: currentAssignment.grid.rows,
					cols: currentAssignment.grid.cols,
					gridState
				},
				goal: currentAssignment.goal
			};
		}
		//otvorene na dalsie typy zadani
	}
	
	
	/*
	function addElementsForAssignment(assignment) {
	
	}
	*/
	
	// metody tykajucesa prepinania rezimov 
	modeHra.onclick = () => {
		modeHra.classList.add("active");
		modeTvorba.classList.remove("active");
		hraSection.classList.remove("hidden");
		tvorbaSection.classList.add("hidden");
	
	};	
	
	modeTvorba.onclick = () => {
		modeHra.classList.remove("active");
		modeTvorba.classList.add("active");
		hraSection.classList.add("hidden");
		tvorbaSection.classList.remove("hidden");
	};

	//po kliknuti na "Volny rezim"
	freeButton.addEventListener("click", () => setFreeMode());

	//po kliknuti na "Vycisti mriezku" sa vycisti mriezka na obrazovke, aj interne
	cleanButton.addEventListener("click", () => cleanGrid());

	//po kliknuti na "Odstran vodu" sa z mriezky odstrania vsetky bunky s vodou (nahradia s prazdnymi bunkami)
	cleanWaterButton.addEventListener("click", () => cleanWaterGrid());

	//po kliknut na "Odstran prekazky" sa z mriezky odstrania vsetky bunky s prekazkami (nahradia sa prazdnymi bunkami)
	cleanObstaclesButton.addEventListener("click", () => cleanObstaclesGrid());
	
	//po kliknuti na "Nacitaj ulohy" sa otvori fileinput element 
	loadButton.addEventListener("click", () => {
		fileInput.value = "";
		fileInput.click();
	});

	//po kliknuti na "Spusti jeden krok" sa vykona jeden krok FloodFill algoritmu
	nextStepButton.addEventListener("click", () => nextStep());

	//po kliknuti na "Spusti program" sa zacne vykonavat algoritmus FloodFill a automaticky sa zmeni na stop button
	runButton.addEventListener("click", () => startSimulation());
	
	//po kliknuti na "Uloz riesenie" sa stiahne subor s nazvom UlohaN-riesenie.json, kde N je cislo ulohy
	saveButton.addEventListener("click", () => {
		//ziskaj udaje o aktualnej session
		const data = getSessionData();

		//preved do json formatu stringu
		const jsonString = JSON.stringify(data, null, 2);
		
		//prevod na json
		const blob = new Blob([jsonString], { type: "application/json" });
		
		//stiahnutie suboru UlohaN-riesenie.json
		const link = document.createElement("a");
		const url = URL.createObjectURL(blob);
		link.href = url;
		link.download = `Úloha${assignmentIndex + 1}-riešenie.json`;
		link.click();

		URL.revokeObjectURL(url);
	});
	
	//po kliknuti "Dalsia uloha" sa prejde na dalsie zadanie
	nextButton.addEventListener("click", () => {
		if (assignments.length > 1) {
			assignmentIndex = (assignmentIndex + 1) % assignments.length;
			cleanGrid();
			showAssignment(assignmentIndex);
		}
	});
	
	fileInput.addEventListener("change", (event) => {
	
		//vybrane jsonFiles
		const files = event.target.files;
		
		//pri nacitani chces zresetovat 
		assignments = []
		
		const promises = Array.from(files).map(file => {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => {
					try {
						const json = JSON.parse(reader.result);
						resolve(json);
					} catch (error) {
						reject(error);
					}
				};
				reader.onerror = () => reject(reader.error);
				reader.readAsText(file);
			});
		});

		// pockam, kym su vsetky jsony precitane
		Promise.all(promises)
			//potom uloz nacitane subory do assignments pola
			.then(results => {
				assignments.push(...results); 
				//vycisti grid, ak je na nom voda alebo prekazky a ukaz prve zadanie
				cleanGrid();
				showAssignment(0);        
		})
		.catch(error => {
			console.error("Chyba pri nacitani json suborov:", error);
		});
	});
	
	const openInfo = document.getElementById("openModal");
	const closeInfo = document.getElementById("closeModal");
	const modal = document.getElementById("modal");
	
	// listenery na popup - ak sa klikne na info Button, tak sa otvori Popup
	openInfo.addEventListener("click", () => {
		modal.classList.add("open");
	});
	
	// ak sa klikne na X button v popupe, tak sa zatvori 
	closeInfo.addEventListener("click", () => {
		modal.classList.remove("open");
	});
	
	// QoL doplnky - ESC tlacitko zatvori popup okno
	document.addEventListener("keydown", e => {
		if(e.key === "Escape") modal.classList.remove("open");
	});
	
	// dizajn - oble okraje gridu
	function setRoundCorners(rows, cols) {
		const cells = document.querySelectorAll("#grid .cell");

		let topLeft = cells[0];
		topLeft.style.borderTopLeftRadius = "10px";
		let topRight = cells[cols - 1]; 
		topRight.style.borderTopRightRadius = "10px";
		let bottomLeft = cells[cells.length - cols];
		bottomLeft.style.borderBottomLeftRadius = "10px";
		let bottomRight = cells[cells.length - 1];
		bottomRight.style.borderBottomRightRadius = "10px";
	}
	
	//dizajn - hrubsi okraj gridu
	function setOuterBorders(rows, cols) {
		const cells = document.querySelectorAll("#grid .cell");
		cells.forEach((cell, index) => {
			const row = Math.floor(index / cols);
			const col = index % cols;
			
			if (row === 0) {
				cell.style.borderTopWidth = "3px";
			}
			if (row === rows - 1) {
				cell.style.borderBottomWidth = "3px";
			}
			if (col === 0) {
				cell.style.borderLeftWidth = "3px";
			}
			if (col === cols - 1) {
				cell.style.borderRightWidth = "3px";
			}
		});
	}
	
	let currentRows = 0;
	let currentCols = 0;

	//funkcia na vycistenie gridu - prenastavenie vsetkych buniek mriezky na "empty"
	function cleanGrid() {
		for (let i = 0; i < currentRows * currentCols; i++) {
			//najdenie prislusnej bunky
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			//vyprazdnenie nastavenim prislusnych classov
			cell.className = "cell cellEmpty";
		}
		
		//vycistenie mriezky aj interne (v 2D poli)
		initializeGridArray(currentRows, currentCols);
	}

	function cleanWaterGrid() {

		//zresetovanie prislusnych premennych drziacich info o vode
		waterCells = [];
		waterCount = 0;

		for (let i = 0; i < currentRows * currentCols; i++) {
			//najdenie prislusnej bunky
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			if (cell.classList.contains("cellWater")) {
				//vyprazdnenie nastavenim prislusnych classov
				cell.className = "cell cellEmpty";
				gridArray[cellRow][cellCol] = 0;
			}
		}
	}

	function cleanObstaclesGrid() {

		//zresetovanie prislusnych premennych drziacich info o prekazkach
		obstacleCells = [];
		obstacleCount = 0;
		for (let i = 0; i < currentRows * currentCols; i++) {
			//najdenie prislusnej bunky
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			if (cell.classList.contains("cellObstacle")) {
				//vyprazdnenie nastavenim prislusnych classov
				cell.className = "cell cellEmpty";
				gridArray[cellRow][cellCol] = 0;
			}
		}
	}

	function setFreeMode() {
		//uchovaj si aktualny assignment type
		assignmentType = "free";
		//pri prepnuti na volny rezim sa vymazu zadania
		assignments = [];
		assignmentIndex = 0;
		//vycisti grid
		cleanGrid();
		//prenastav divs v task-div
		document.getElementById("levelCounter").innerHTML = "<p> Voľný režim </p>";
		document.getElementById("zadanieHeader").innerText = "";
		document.getElementById("task").innerHTML = "<p> Aktuálne sa nachádzate vo voľnom režime, v ktorom môžete do mriežky pridávať <u>prekážky</u> a <u>zdroje vody</u>. Pre načítanie zadaní úloh kliknite na tlačítko <b>Načítaj úlohy</b>.</p>";
	}

	let waterCount = 0;

	//pridanie vody do bunky [cellRow, cellCol], respektive jej odstranenie, ak v nej voda uz je
	function handleLeftClick(cell, cellRow, cellCol) {

		//pri zadani typu "avoid_cells" sa nemoze pridavat voda
		if (assignmentType === "avoid_cells") return;

		//ak uz je v bunke voda, tak vyprazdni bunku
		if (gridArray[cellRow][cellCol] === 1) {
			waterCount = waterCount - 1;
			gridArray[cellRow][cellCol] = 0;
			cell.className = "cell cellEmpty";
			// waterCells.remove(cell);
			let index = waterCells.indexOf(cell);
			if (index != -1) waterCells.splice(index, 1);
			
		}
		//inak tam pridaj vodu
		else {
			//pri zadani typu "fastest_fill" je pocet policok vody obmedzeny na jedno
			if (assignmentType === "fastest_fill" && (waterCount > 0 || cell.classList.contains("cellObstacle"))) return;
			waterCount = waterCount + 1;
			gridArray[cellRow][cellCol] = 1;
			cell.className = "cell cellWater";
			waterCells.push(cell);
		}
	}

	let obstacleCount = 0;

	//pridanie prekazky do bunky [cellRow, cellCol], respektive jej odstranenie, ak v nej prekazka uz je
	function handleRightClick(cell, cellRow, cellCol) {

		//pri zadani typu "avoid_cells" je obmedzeny pocet prekazok v mriezke na .goal.minNumofObstacles
		if (assignmentType === "avoid_cells" && obstacleCount > currentAssignment.goal.minNumOfObstacles - 1) return;

		//pri zadani typu "fastest_fill" sa do mriezky nepridavaju prekazky
		if (assignmentType === "fastest_fill") return;

		//ak uz je v bunke prekazka, tak vyprazdni bunku
		if (gridArray[cellRow][cellCol] === 2) {
			obstacleCount = obstacleCount - 1;
			gridArray[cellRow][cellCol] = 0;
			cell.className = "cell cellEmpty";
			//obstacleCells.remove(cell);
			let index = obstacleCells.indexOf(cell);
			if (index != -1) obstacleCells.splice(index, 1);
		}
		//inak tam pridaj prekazku
		else {
			obstacleCount = obstacleCount + 1;
			gridArray[cellRow][cellCol] = 2;
			cell.className = "cell cellObstacle";
			obstacleCells.push(cell);
		}
	}
	
	const grid = document.getElementById("grid");

	//funkcia na vytvorenie mriezky rozmerov [riadky, stlpce], sizePolicka je velkost jednej bunky/stvorceka
	//zaklad 8x8
	function generateGrid(rows = 8, cols = 8) {
		
		currentRows = rows;
		currentCols = cols;
	
		initializeGridArray(rows, cols);

		const grid = document.getElementById("grid");
		grid.innerHTML = "";
		
		//velkost mriezky - aby sa to zmestilo na obrazovku bez scrollovania
		const maxGridSize = Math.min(window.innerWidth, window.innerHeight) * 0.5;
		
		//dynamicky zmenit velkost bunky v zavislosti od poctu riadkov/stlpcov
		let cellSize = Math.floor(Math.min(maxGridSize/rows, maxGridSize/cols));
		//najvacsia velkost bunky
		if (cellSize > 80) cellSize = 80;

		document.getElementById("grid").style.height = cellSize * currentRows + " px";	
		

		// nastavenie poctu stlpcov a velkost bunky
		grid.style.gridTemplateColumns = "repeat(" + cols + ", " + cellSize + "px)";
  
		// nastavenie poctu riadkov a velkost bunky
		grid.style.gridTemplateRows = "repeat(" + rows + ", " + cellSize + "px)";
		
		//vytvorenie buniek
		for (let i = 0; i < currentRows * currentCols; i++) {
			let cell = document.createElement("div");
			cell.classList.add("cell", "cellEmpty"); // defaultne je bunka prazdna, pridanie class="cellEmpty" (two-class approach)
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			cell.id = `cell-${cellRow}-${cellCol}`; // id v tvare cell-row-col
			cell.addEventListener("click", () => handleLeftClick(cell, cellRow, cellCol));
			cell.addEventListener("contextmenu", (e) => {
				e.preventDefault();
				handleRightClick(cell, cellRow, cellCol);
			});
			grid.appendChild(cell);
		}
		
		//funkcia na oble okraje mriezky
		setRoundCorners(rows, cols);
		
		//funkcia na hrubsie vonkajsie okraje mriezky
		setOuterBorders(rows, cols);
		
	}
	
	/* defaultny grid (8x8 v hlavicke funkcie) */
	generateGrid();

	//window.addEventListener("resize", () => generateGrid());

	function nextStep() {
		//kopia mriezky, aby nova voda neovplyvnila fill
		let newGridArray = gridArray.map(arr => [...arr]);

		//boolean trackujuci zmenu v mriezke
		let changed = false;

		// floodfill algoritmus
		for (let row = 0; row < gridArray.length; row++) {
			for (let col = 0; col < gridArray[row].length; col++) {
				//ak je v bunke voda, tak sa rozsiruj do susedov, voda = 1
				if (gridArray[row][col] === 1) {
					//susedia bunky cell = [row][col]
					const neighbours = [
						[row - 1, col], //horny sused
						[row + 1, col], //dolny sused
						[row, col - 1], //lavy sused
						[row, col + 1] //pravy sused
					];

					neighbours.forEach(([nRow, nCol]) => {
						//ak je riadok suseda v rozsahu mriezky
						if (nRow >= 0 && nRow < gridArray.length 
						// a zaroven ak je stlpec suseda v rozsahu mriezky
						&& nCol >= 0 && nCol < gridArray[row].length
						//a zaroven ak je bunka [nRow][nCol] prazdna (0)
						&& gridArray[nRow][nCol] === 0) {
							//pridaj do tej bunky vodu (1)
							newGridArray[nRow][nCol] = 1;
							//nastala zmena v mriezke
							changed = true;
							//prenastav div bunky aj na stranke
							const newWaterCell = document.getElementById(`cell-${nRow}-${nCol}`);
							newWaterCell.classList.remove("cellEmpty");
							newWaterCell.classList.add("cellWater");
						}
					});
				}
			}
		}

		//prekopiruj novu mriezku do globalneho pola pre mriezku
		gridArray = newGridArray;

		//ak sa nic do mriezky nepridalo, tak ukonci simulaciu
		if (!changed) stopSimulation();
	}
	
	//window.addEventListener("resize", () => generateGrid());

	//nastavenie stavu buttonu (toggle = true-enabled/false-disabled)
	function setButtonState(buttonId, toggle) {
		const button = document.getElementById(buttonId);
		//buttony mozu byt v button-wrapper alebo v sidebar-button-wrapper (column vs row rozlozenie button-label)
		let wrapper = button.closest(".button-wrapper");
		if (wrapper == null) {
			wrapper = button.closest(".sidebar-button-wrapper");
		}

		//ak je toggle = true, tak enable button-label
		if (toggle) {
			button.disabled = false;
			wrapper.classList.remove("disabled");
		//inak disable
		} else {
    		button.disabled = true;
			wrapper.classList.add("disabled");
 		}
	}

	let simulationInterval;

	//funkcia na spustenie algoritmu FloodFillu
	function startSimulation() {
		//vypni vsetky zvysne buttony, ked prebieha algoritmus
		setButtonState("freeButton", false);
		setButtonState("loadButton", false);
		setButtonState("upravButton", false);
		setButtonState("nextStepButton", false);
		setButtonState("cleanButton", false);
		setButtonState("cleanWaterButton", false);
		setButtonState("cleanObstaclesButton", false);
		setButtonState("saveButton", false);
		setButtonState("nextButton", false);

		//zmen run button na stop button
		document.getElementById("runButtonDiv").innerHTML = '<button type="button" class="button" id="stopButton" onclick="stopSimulation()"><img src="icons/stop.png" class="icon" width="50px" height="50px"></button><span class="label" id="stopLabel"> Stopni program </span>';

		//kazdych 0.5sekundy sa vykona jeden krok floodfill algoritmu
		simulationInterval = setInterval(() => {
			nextStep();
		}, 500);
	}

	//funkcia na zastavenie algoritmu FloodFillu
	function stopSimulation() {
		//znovu zapne vsetky zvysne buttony, pretoze sa stopol algoritmus 
		setButtonState("freeButton", true);
		setButtonState("loadButton", true);
		setButtonState("upravButton", true);
		setButtonState("nextStepButton", true);
		setButtonState("cleanButton", true);
		setButtonState("cleanWaterButton", true);
		setButtonState("cleanObstaclesButton", true);
		setButtonState("saveButton", true);
		setButtonState("nextButton", true);

		//zmen stop button na run button
		document.getElementById("runButtonDiv").innerHTML = '<button type="button" class="button" id="runButton" onclick="startSimulation()"><img src="icons/play-button.png" class="icon" width="50px" height="50px"></button><span class="label" id="runLabel"> Spusti program </span>';
		if (simulationInterval) {
			clearInterval(simulationInterval);
			simulationInterval = null;
		}
	}
	
</script>

</body>
</html>

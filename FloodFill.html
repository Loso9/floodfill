<!DOCTYPE html>
<html lang="sk">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title> Ako tečie voda </title>
	<link rel="icon" href="icons/water.png" type="image/png">
	<link href="style.css" rel="stylesheet" />
</head>
<body>

<!-- V headeri sa nachadza primarne button o informaciach o projekte -->
<header>
	<!-- Button "Informacie" -->
	<div class="button-wrapper">
		<button type="button" class="button" title="Informácie o stránke" id="openModal"> 
			<img src="icons/information.png" class="icon" width="50px" height="50px"> 
		</button>
		<span class="label" id="infoLabel"> Informácie </span>
	</div>
	
	<!-- Popup okno, ktore sa otvori po kliknuti na Button "Informacie" -->
	<div class="modal" id="modal">
		<div class="modal-inner">
			
			<!-- Button Zatvor Popup -->
			<div class="button-wrapper">
				<button type="button" class="button" title="Zavrieť okno" id="closeModal"> 
					<img src="icons/close.png" class="icon" width="25px" height="25px"> 
				</button>
			</div>
			
			<!-- Text popupu -->
			
			<p> 
			Projekt <i>Ako tečie voda </i> je inšpirovaný algoritmom <b>FloodFill</b>. V tomto softvéri má používateľ k dispozícií dva 
			režijné módy - Hra a Tvorba. V režime Hra má používateľ možnosť riešiť úlohy na mriežke, týkajúce sa spomínaného algoritmu.
			Vzhľadom na zadanie bude používateľ v móde Hra pridávať prekážky alebo určovať, odkiaľ sa má 
			začať liať voda. Projekt je písaný vo forme, v ktorej sa dá jednoducho implementovať ďalšie typy zadaní. 
			</p>
			<div id="linkSpecifikacia">
				<a href="specs.pdf" target="_blank"> Špecifikácia projektu </a>
			</div>
			<div id="linkGithub">
				<a href="https://github.com/Loso9/floodfill" target="_blank"> GitHub repozitár </a>
			</div>
		</div>
	</div>
</header>


<!-- Nadpisy -->
<h1> Ako tečie voda </h1>
<h2> Marek Lošonský, Martin Hošek </h2>

<!-- Div na rezimy hry -->
<div class="mode-switch">
	<span id="mode-hra" class="active"> HRA </span>
	<span id="mode-tvorba"> TVORBA </span>
</div>


<!-- Seria Buttonov pre herny rezim -->
<div id="hra-buttony">
	<div class="button-bar">
		<!-- zatial nevyuzity button Zadanie 
		<div class="button-wrapper">
			<button type="button" class="button" title="Zobraz zadanie"> 
				<img src="icons/quest.png" class="icon" width="40px" height="40px"> 
			</button>
			<span class="label" id="zadanieLabel"> Zadanie </span>
		</div> 
		-->
		<div class="button-wrapper" id="freeButtonDiv">
			<button type="button" class="button" id="freeButton"> 
				<img src="icons/free.png" class="icon" width="50px" height="50px"> 
			</button>
			<span class="label" id="freeLabel"> Voľný režim </span>
		</div>
		<div class="button-wrapper" id="loadButtonDiv">
			<button type="button" class="button" id="loadButton"> 
				<img src="icons/load.png" class="icon" width="50px" height="50px"> 
			</button>
			<!-- neviditelny input element pre filepicker -->
			<input type="file" multiple id="fileInput" accept=".json" style="display: none;"/>
			<span class="label" id="loadLabel"> Načítaj úlohy </span>
		</div>
		<div class="button-wrapper" id="loadSolutionButtonDiv" style="display: none;">
			<button type="button" class="button" id="loadSolutionButton"> 
				<img src="icons/upload.png" class="icon" width="50px" height="50px"> 
			</button>
			<!-- neviditelny input element pre filepicker -->
			<input type="file" id="solutionFileInput" accept=".json" style="display: none;"/>
			<span class="label" id="loadSolutionLabel"> Načítaj riešenie </span>
		</div>
		<div class="button-wrapper" id="nextStepButtonDiv">
			<button type="button" class="button" id="nextStepButton"> 
				<img src="icons/one.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="nextStepLabel"> Spusti jeden krok </span>
		</div>
		<div class="button-wrapper" id="runButtonDiv">
			<button type="button" class="button" id="runButton">
				<img src="icons/play-button.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="runLabel"> Spusti program </span>
		</div>
		<div class="button-wrapper" id="saveButtonDiv">
			<button type="button" class="button" id="saveButton">
				<img src="icons/save.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="ulozLabel"> Ulož riešenie </span>
		</div>
		<div class="button-wrapper" id="nextButtonDiv">
			<button type="button" class="button" id="nextButton">
				<img src="icons/arrow.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="dalejLabel"> Ďalšia úloha </span>
		</div>
	</div>
</div>



<!-- Div v ktorom bude jednak mriezka (vlavo) a zadanie (vpravo), !!! a extra buttony podla zadania vlavo -->
<div id="hra-section">
	<div id="center-section">
		<div id="task-wrapper">
			<div id="levelCounter">
				<p> Voľný režim </p>
			</div>
			<h3 id="zadanieHeader"> Zadanie </h3>
			<div id="task">
				<p> 
				Aktuálne sa nachádzate vo voľnom režime, v ktorom môžete do mriežky pridávať <u>prekážky</u> a <u>zdroje vody</u>. 
				Pre načítanie zadaní úloh kliknite na tlačítko <b>Načítaj úlohy</b>.
				</p>
			</div>
			<div id="solutionDiv"> </div> 
		</div>
		<div id="sidebar-grid">
			<div id="grid-wrapper">
				<div id="grid"> </div>
				<div id="gridInfo">
					<span id="rowCountLabel"> </span>
					<span id="colCountLabel"> </span>
				</div>
			</div>
			<div id="sidebar">
				<div id="sidebar-top">
					<span class="label" id="helperLabel"> Nástroje </span>
					<div class="sidebar-button-wrapper" id="cleanButtonDiv">
						<button type="button" class="button" id="cleanButton"> 
							<img src="icons/clean.png" class="icon" width="30px" height="30px">
						</button>
						<span class="label" id="cleanLabel"> Vyčisti mriežku </span>
					</div>
					<div class="sidebar-button-wrapper" id="cleanWaterButtonDiv">
						<button type="button" class="button" id="cleanWaterButton"> 
							<img src="icons/delete-water.png" class="icon" width="30px" height="30px">
						</button>
						<span class="label" id="cleanWaterLabel"> Odstráň vodu </span>
					</div>
					<div class="sidebar-button-wrapper" id="cleanObstaclesButtonDiv">
						<button type="button" class="button" id="cleanObstaclesButton"> 
							<img src="icons/delete-obstacles.png" class="icon" width="30px" height="30px">
						</button>
						<span class="label" id="cleanObstaclesLabel"> Odstráň prekážky </span>
					</div>
					<div class="sidebar-button-wrapper-double" id="adjustRowsButtonsDiv">
						<button type="button" class="button" id="addRowsButton"> 
							<img src="icons/plus.png" class="icon" width="30px" height="30px">
						</button>
						<button type="button" class="button" id="removeRowsButton"> 
							<img src="icons/minus.png" class="icon" width="30px" height="30px">
						</button>
						<span class="label" id="adjustRowsLabel">
    						<span class="label-add">&nbsp Pridaj riadok </span>&nbsp&nbsp | &nbsp&nbsp<span class="label-remove">Odstráň riadok</span>
  						</span>
					</div>
					<div class="sidebar-button-wrapper-double" id="adjustColumnsButtonsDiv">
						<button type="button" class="button" id="addColumnsButton"> 
							<img src="icons/plus.png" class="icon" width="30px" height="30px">
						</button>
						<button type="button" class="button" id="removeColumnsButton"> 
							<img src="icons/minus.png" class="icon" width="30px" height="30px">
						</button>
						<span class="label" id="adjustColumnsLabel">
    						<span class="label-add">&nbsp Pridaj stĺpec </span>&nbsp&nbsp | &nbsp &nbsp<span class="label-remove">Odstráň stĺpec</span>
  						</span>
					</div>
					<div class="sidebar-button-wrapper" id="resetButtonDiv">
						<button type="button" class="button" id="resetButton"> 
							<img src="icons/undo.png" class="icon" width="30px" height="30px">
						</button>
						<span class="label" id="resetLabel"> Začni odznovu </span>
					</div>
				</div>
				<!-- v spodnom sidebare nebudu buttony, ale iba ikony -->
				<div id="sidebar-bottom">
					<span class="label" id="helperLabel"> Pomôcka </span>
					<div class="sidebar-icon-wrapper" id="addWaterIconDiv">
						<img src="icons/left-click.png" class="icon" width="30px" height="30px">
						<span class="label" id="leftClickLabel"> Pridaj vodu </span>
					</div>
					<div class="sidebar-icon-wrapper" id="addObstacleIconDiv">
						<img src="icons/right-click.png" class="icon" width="30px" height="30px">
						<span class="label" id="rightClickLabel"> Pridaj prekážku </span>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Tabulka so zadaniami, pokusmi a oznacenim, ci je vyriesenena alebo nie -->
	<div class="progressTable" id="progressTable">
	</div>
</div>

<!-- CAST 2 - MOD TVORBA, !!! TODO -->
<div id="tvorba-section"> </div>

<!-- Päta stranky -->
<footer>
	<p> Softvér pre vzdelávanie, 1mAIN, 2025/2026 </p>
</footer>

<script>
	const modeHra = document.getElementById("mode-hra");
	const modeTvorba = document.getElementById("mode-tvorba");
	const hraSection = document.getElementById("hra-section");
	const tvorbaSection = document.getElementById("tvorba-section");
	const loadButton = document.getElementById("loadButton");
	const fileInput = document.getElementById("fileInput");
	const nextButton = document.getElementById("nextButton");
	const saveButton = document.getElementById("saveButton");
	const runButton = document.getElementById("runButton");
	const nextStepButton = document.getElementById("nextStepButton");
	const cleanButton = document.getElementById("cleanButton");
	const cleanWaterButton = document.getElementById("cleanWaterButton");
	const cleanObstaclesButton = document.getElementById("cleanObstaclesButton");
	const freeButton = document.getElementById("freeButton");
	const saveButtonDiv = document.getElementById("saveButtonDiv");
	const nextButtonDiv = document.getElementById("nextButtonDiv");
	const cleanButtonDiv = document.getElementById("cleanButtonDiv");
	const cleanWaterButtonDiv = document.getElementById("cleanWaterButtonDiv");
	const cleanObstaclesButtonDiv = document.getElementById("cleanObstaclesButtonDiv");
	const adjustRowsButtonsDiv = document.getElementById("adjustRowsButtonsDiv");
	const addRowsButton = document.getElementById("addRowsButton");
	const addColumnsButton = document.getElementById("addColumnsButton");
	const removeRowsButton = document.getElementById("removeRowsButton");
	const removeColumnsButton = document.getElementById("removeColumnsButton");
	const adjustColumnsButtonsDiv = document.getElementById("adjustColumnsButtonsDiv");
	const loadButtonDiv = document.getElementById("loadButtonDiv");
	const freeButtonDiv = document.getElementById("freeButtonDiv");
	const nextStepButtonDiv = document.getElementById("nextStepButtonDiv");
	const runButtonDiv = document.getElementById("runButtonDiv");
	const resetButton = document.getElementById("resetButton");
	const resetButtonDiv = document.getElementById("resetButtonDiv");
	const loadSolutionButtonDiv = document.getElementById('loadSolutionButtonDiv');
	const loadSolutionButton = document.getElementById('loadSolutionButton');
	const solutionFileInput = document.getElementById('solutionFileInput');
	const openInfo = document.getElementById("openModal");
	const closeInfo = document.getElementById("closeModal");
	const modal = document.getElementById("modal");
	
	//pomocne pole kde si budeme ukladat zadania
	let assignments = [];
	let assignmentsLocal = []; //ulozene zadania v local storage
	//defaultne je volny rozim (ziadne zadanie)
	let assignmentIndex = 0;
	
	let currentAssignment; //aktualny assignment
	let initialGridSnapshot = []; // snapshot mriezky ako bola nacitana zo zadania pre reset
	let cellSize; //velkost bunky v mriezke
	
	let gridArray = []; // 2D pole reprezentujuce mriezku
	let waterCells = []; //bunky obsahujuce vodu
	let obstacleCells = []; //bunky obsahujuce prekazku
	let emptyCells = []; //prazdne bunky

	//zdroj vody (primarne pre fastest fill) - forma [[row, col], [row2, col2], ...]
	let waterSource = [];

	//pole fixnych prekazok (zo zadania) - forma [[row, col], [row2, col2], ...]
	let fixedObstacles = [];

	//pole krokov, ako sa zaplna mriezka (pre fastest_fill) - forma [{row, col: 2, row2, col2: 5, ...}, {row, col: 3, row2, col2: 7}, ...] - na kazdom indexe i je mapa krokov [policko] - krok zaplnenia (index i je index zadania)
	let fillSteps = [];

	//na zaciatku programu je volny mod, ked moze uzivatel pridavat prekazky a pridavat vodu a skusat, ako funguje algoritmus
	let assignmentType = "free";

	//pole, v ktorom si na indexe i pamatame, ci zadanie s indexom i uz skoncilo simulaciu
	let simulationFinished = [];
	
	// Inicializacia 2D pola na zaklade poctu riadkov a stlpcov
	function initializeGridArray(rows, cols) {
		// 0 znamena prazdne policko v array reprezentacii
		gridArray = Array.from({ length: rows }, () => Array(cols).fill(0));
	}

	// preved stav mriezky do internych poli
	function syncStatesWithGrid() {

		//console.log("syncStatesWithGrid - gridArray:", gridArray);
		waterCount = 0;
		waterCells = [];
		obstacleCount = 0;
		obstacleCells = [];
		emptyCount = 0;
		emptyCells = [];
		//waterSource[assignmentIndex] = [];
		//fillSteps[assignmentIndex] = {};
		
		for (let row = 0; row < currentRows; row++) {
			for (let col = 0; col < currentCols; col++) {
				const value = gridArray[row][col];
				const cell = document.getElementById(`cell-${row}-${col}`);
				if (!cell) continue;
				//ak je v bunke voda
				if (value === 1) {
					waterCount = waterCount + 1;
					waterCells.push(cell);
				} 
				//ak je v bunke prekazka
				else if (value === 2) {
					obstacleCount = obstacleCount + 1;
					obstacleCells.push(cell);
				} 
				//ak je bunka prazdna
				else {
					emptyCount = emptyCount + 1;
					emptyCells.push(cell);
				}
			}
		}
	}

	function updateCounter() {
		const counter = document.getElementById("levelCounter");
		
		//ak mam len jedno zadanie, tak napise do div len "Uloha"
		if (assignments.length === 1) {
			counter.innerText = "Úloha";
		}
		else if (assignments.length > 1) {
			//updatni counter vo forme Uloha M/N, kde M je aktualne cislo ulohy a N je pocet vsetkych nacitanych uloh
			counter.innerHTML = "Úloha " + (assignmentIndex + 1) + "/" + assignments.length;
		}
		else {
			//nic nebolo nacitane
			counter.innerText = "";
		}
	}
	
	function updateProgressTable() {
		const progressTable = document.getElementById("progressTable");
		progressTable.innerHTML = ""; // Clear the table

		let tableHTML = "<table><tr><th>Úloha</th><th>Pokusy</th><th>Status</th></tr>";

		assignmentsLocal.forEach((assignment, index) => {
			const isSelected = index === assignmentIndex ? " class='selectedLevel'" : "";
			tableHTML += `
				<tr>
					<td${isSelected} onclick="switchToLevelById(${index})" onmouseover="this.style.backgroundColor='#f0f0f0';" onmouseout="this.style.backgroundColor='';" style="cursor: pointer;">Úloha ${index + 1}</td>
					<td${isSelected}>${assignment.pokusy || 0}</td>
					<td${isSelected}>${assignment.vyriesene ? "✔️" : "❌"}</td>
				</tr>
			`;
		});

		progressTable.innerHTML = tableHTML + "</table>";
	}

	function showAssignment(index) {
		//console.log("assignmentsLocal:", assignmentsLocal);
		//console.log("Current assignment index:", assignmentIndex);
		currentAssignment = assignmentsLocal[index];
		

		assignmentIndex = index;
		
		assignmentType = currentAssignment.type;

		updateProgressTable();
		
		//ak nemam zadanie, tak nic nerob
		if (!currentAssignment) return;

		//uprav pocitadlo currentRows a currentCols podla zadania a vygeneruj podla toho mriezku

		//console.log("Current assignment:", currentAssignment);
		currentRows = currentAssignment.grid.rows;
		currentCols = currentAssignment.grid.cols;
		generateGrid(currentRows, currentCols);
		
		let assignmentText = currentAssignment.text;
		
		//formatovanie zadania
		//assignmentText = assignmentText.replaceAll("{{target}}", `<u>${currentAssignment.targetWord}</u>`);
		if (currentAssignment.type === "avoid_cells") {
			document.getElementById("task").innerHTML = generateTextAvoidCells();
		} else if (currentAssignment.type === "fastest_fill") {
			document.getElementById("task").innerHTML = generateTextFastestFill();
		}

		//nacitaj do interneho pola stav mriezky z JSONu (deep copy to avoid accidental mutation)
		gridArray = currentAssignment.grid.gridState.map(row => [...row]);
	
		
		if (initialGridSnapshot[assignmentIndex] !== null) {
			// uz mame zapamatany snapshot mriezky zadania, nerob nic
		}
		//zapamatuj si pociatocny stav mriezky pre reset
		else initialGridSnapshot[assignmentIndex] = currentAssignment.grid.gridState.map(row => [...row]);
		

		for (let row = 0; row < currentRows; row++) {
			for (let col = 0; col < currentCols; col++) {
				if (initialGridSnapshot[assignmentIndex][row][col] === 2) {
					fixedObstacles[assignmentIndex].push([row, col]);
				}
			}
		}

		//nacitaj do mriezky na stranke stav mriezky z JSONu
		for (let row = 0; row < gridArray.length; row++) {
			for (let col = 0; col < gridArray[row].length; col++) {
				let cellId = `cell-${row}-${col}`;
				let cell = document.getElementById(cellId);
				let iconSize = 0;
				//ak je bunka prazdna
				if (gridArray[row][col] === 0) {
					cell.className = "cell cellEmpty";
				}
				//ak je v bunke voda
				else if (gridArray[row][col] === 1) {
					cell.className = "cell cellWater";
					iconSize = cellSize * 0.7;
					if (waterSource[assignmentIndex] && waterSource[assignmentIndex].some(([r, c]) => r === row && c === col)) {
						cell.innerHTML = `<img src="icons/waterCell.png" class="icon" width="${iconSize}" height="${iconSize}">`;
					}
				}
				//ak je v bunke prekazka
				else if (gridArray[row][col] === 2) {
					cell.className = "cell cellObstacle";
					if (!fixedObstacles[assignmentIndex].some(([r, c]) => r === row && c === col)) {
						iconSize = cellSize;
						cell.innerHTML = `<img src="icons/big.png" class="icon" width="${iconSize}" height="${iconSize}">`;
					}
					else {
						iconSize = cellSize * 0.8;
						cell.innerHTML = `<img src="icons/mountain.png" class="icon" width="${iconSize}" height="${iconSize}">`;
					}
				}
			}
		}

		//vloz do mriezky kroky 
		if (assignmentType === "fastest_fill" && fillSteps[assignmentIndex]) {
			for (const key in fillSteps[assignmentIndex]) {
				const [row, col] = key.split(",").map(Number);
				const cell = document.getElementById(`cell-${row}-${col}`);
    			if (cell && gridArray[row][col] === 1) {
      				cell.textContent = fillSteps[assignmentIndex][key] + 1;
    			}
			}
		}

		//zvys cislo uloha nad zadanim
		updateCounter();

		//ked je nacitane zadanie, tak ukaz vsetky buttony v top bare
		showNonFreeButtons();

		//synchronizuj pomocne polia s aktualnym stavom mriezky
		syncStatesWithGrid();

		//ak mame zadanie, tak pridam zobrazim aj reset tlacitko
		resetButtonDiv.style.display = "";

		//bolo nacitanie zadanie, zobraz tlacitko na nahratie riesenia
		loadSolutionButtonDiv.style.display = '';

		//v sidebare zobraz len tie ikony, ktore su relevantne pre dane zadanie (v avoid_cells pridavam len prekazky, teda pomocka je len
		//pre pridavanie prekazok, v fastest_fill pridavam len vodu, teda pomocka je len pre pridavanie vody)
		if (assignmentType === "avoid_cells") {
			cleanButtonDiv.style.display = "none";
			cleanWaterButtonDiv.style.display = "none";
			cleanObstaclesButtonDiv.style.display = "none";
			adjustRowsButtonsDiv.style.display = "none";
			adjustColumnsButtonsDiv.style.display = "none";
			addWaterIconDiv.style.display = "none";
			addObstacleIconDiv.style.display = "";			
		}
		else if (assignmentType === "fastest_fill") {
			cleanButtonDiv.style.display = "none";
			cleanWaterButtonDiv.style.display = "none";	
			cleanObstaclesButtonDiv.style.display = "none";
			adjustRowsButtonsDiv.style.display = "none";
			adjustColumnsButtonsDiv.style.display = "none";
			addWaterIconDiv.style.display = "";
			addObstacleIconDiv.style.display = "none";
		}

		//uprav text riesenia
		updateSolutionDiv();
	}
	
	//funkcia na ukladanie aktualnej session do jsonu 
	function getSessionData() {
		//ak nie je zadanie, tak neuloz nic
		if (!currentAssignment) return null;

		// ak nebolo zadanie, vytvor aspon nejake ID
		if (currentAssignment && !currentAssignment.id) {
			// vygeneruj unikatne ID pre aktualne zadanie
			currentAssignment.id = generateAssignmentId();
		}

		const type = currentAssignment.type || assignmentType;

		//objekt, v ktorom si pamatame pole prekazok a zdrojov vody
		const placements = { obstacles: [], waterSource: [...waterSource[assignmentIndex]] };

		//ak je zadanie typu avoid_cells, tak json bude vyzerat takto
		if (type === "avoid_cells") {
			const fixed = fixedObstacles[assignmentIndex] || [];

			for (let row = 0; row < currentRows; row++) {
				for (let col = 0; col < currentCols; col++) {
					const value = gridArray[row][col];
					if (value === 2 && !fixed.some(([r, c]) => r === row && c === col)) placements.obstacles.push([row, col]);
					// else if (value === 1) placements.waterSource.push([row, col]);
				}
			}

			const metrics = {
				obstacleCount: placements.obstacles.length,
				dryCells: (currentRows * currentCols) - waterCount - obstacleCount 
			}

			return {
				type: "solution",
				assignmentId: currentAssignment.id,
				createdAt: new Date().toISOString(),
				placements,
				metrics
        	};

		}

		//ak je zadanie typu fastest_fill, tak riesenie bude vyzerat takto
		else if (type === "fastest_fill") {
			placements.waterSource = Array.isArray(waterSource[assignmentIndex]) ? [...waterSource[assignmentIndex]] : [];

			const metrics = {
				waterCount: placements.waterSource.length,
				steps: stepsCounter[assignmentIndex] ?? 0
			};

			return {
				type: "solution",
				assignmentId: currentAssignment.id,
				createdAt: new Date().toISOString(),
				placements,
				metrics
			};
		}
	}


	//vygeneruj unikatne ID pre aktualne zadanie
	function generateAssignmentId() {
		return crypto.randomUUID();
	}
	
	// metody tykajucesa prepinania rezimov 
	modeHra.onclick = () => {
		modeHra.classList.add("active");
		modeTvorba.classList.remove("active");
		hraSection.classList.remove("hidden");
		tvorbaSection.classList.add("hidden");
		if (assignmentType && assignmentType !== 'free' && assignments && assignments.length > 0) {
			showNonFreeButtons();
		} else {
			hideNonFreeButtons();
		}
	};	
	
	modeTvorba.onclick = () => {
		modeHra.classList.remove("active");
		modeTvorba.classList.add("active");
		hraSection.classList.add("hidden");
		tvorbaSection.classList.remove("hidden");
	};

	//po kliknuti na "Volny rezim"
	freeButton.addEventListener("click", () => setFreeMode());

	//po kliknuti na "Vycisti mriezku" sa vycisti mriezka na obrazovke, aj interne
	cleanButton.addEventListener("click", () => cleanGrid());

	//po kliknuti na "Odstran vodu" sa z mriezky odstrania vsetky bunky s vodou (nahradia s prazdnymi bunkami)
	cleanWaterButton.addEventListener("click", () => cleanWaterGrid());

	//po kliknut na "Odstran prekazky" sa z mriezky odstrania vsetky bunky s prekazkami (nahradia sa prazdnymi bunkami)
	cleanObstaclesButton.addEventListener("click", () => cleanObstaclesGrid());

	//po kliknuti na "Pridaj riadok" sa v mriezke prida riadok na koniec
	addRowsButton.addEventListener("click", () => addRow());

	//po kliknuti na "Pridaj stlpec" sa v mriezke prida stlpec na koniec 
	addColumnsButton.addEventListener("click", () => addColumn());

	//po kliknut na "Odstran riadok" sa v mriezke odstrani posledny riadok
	removeRowsButton.addEventListener("click", () => removeRow());

	//po kliknut na "Odstran riadok" sa v mriezke odstrani pesledny stlpec
	removeColumnsButton.addEventListener("click", () => removeColumn());

	//po kliknuti na "Zacni odznovu" sa z mriezky odstrania vsetky bunky v zavislosti od zadania
	resetButton.addEventListener('click', () => {
		if (!currentAssignment || !initialGridSnapshot[assignmentIndex]) {
			//nebolo nacitane zadanie, tak len vycisti mriezku
			cleanGrid();
			return;
		}

		//ak je zadanie "avoid_cells", obnov mriezku do pociatocneho stavu zo zadania (vycistit cele))
		if (assignmentType === 'avoid_cells') {
			cleanGrid();
			// Obnov mriezku do pociatocneho stavu zo zadania
			for (let row = 0; row < currentRows; row++) {
				for (let col = 0; col < currentCols; col++) {
					const cell = document.getElementById(`cell-${row}-${col}`);
					cell.innerText = "";
					const val = initialGridSnapshot[assignmentIndex][row][col];
					if (val === 2) {
						gridArray[row][col] = 2;
						cell.className = "cell cellObstacle";
						iconSize = cellSize * 0.8;
						cell.innerHTML = `<img src="icons/mountain.png" class="icon" width="${iconSize}" height="${iconSize}">`;
					} else if (val === 1) {
						gridArray[row][col] = 1;
						cell.className = "cell cellWater";
					} else {
						gridArray[row][col] = 0;
						cell.className = "cell cellEmpty";
					}
				}
			}
			syncStatesWithGrid();
		} 
		else if (assignmentType === 'fastest_fill') {
			stepsCounter[assignmentIndex] = 0;
			// odstran iba vodu, ktora bola pridana uzivatelom, prekazky nechaj
			cleanGrid();
			for (let row = 0; row < currentRows; row++) {
				for (let col = 0; col < currentCols; col++) {
					const cell = document.getElementById(`cell-${row}-${col}`);
					cell.innerText = "";
					const val = initialGridSnapshot[assignmentIndex][row][col];
					if (val === 2) {
						gridArray[row][col] = 2;
						cell.className = "cell cellObstacle";
						iconSize = cellSize * 0.8;
						cell.innerHTML = `<img src="icons/mountain.png" class="icon" width="${iconSize}" height="${iconSize}">`;
					} else if (val === 1) {
						gridArray[row][col] = 1;
						cell.className = "cell cellWater";
					} else {
						gridArray[row][col] = 0;
						cell.className = "cell cellEmpty";
					}
				}
			}
			//odstran zdroje vody
			waterSource[assignmentIndex] = [];
			syncStatesWithGrid();
		}

		//po resetovani samozrejme ze zaciname odznovu a teda simulacia nie je ukoncena
		simulationFinished[assignmentIndex] = false;
		updateSolutionDiv();
		//solutionDiv.innerText = "";
		//otvorene na dalsie typy zadani
	});

	
	//po kliknuti na "Nacitaj ulohy" sa otvori fileinput element 
	loadButton.addEventListener("click", () => {
		fileInput.value = "";
		fileInput.click();
		
	});

	//po kliknuti na "Nacitaj riesenie" sa otvori fileinput element
	loadSolutionButton.addEventListener("click", () => {
		solutionFileInput.value = "";
		solutionFileInput.click();
	});

	//po kliknuti na "Nacitaj riesenie" sa nacita JSON subor a aplikuje sa na mriezku
	solutionFileInput.addEventListener("change", (event) => {
		const file = event.target.files && event.target.files[0];

		//ak nie je subor, tak nic nerob
		if (!file) return;
		const reader = new FileReader();
		reader.onload = async (e) => {
			try {
				const solution = JSON.parse(e.target.result);

				//podmienky - riesenie ma byt typu "solution" a zadania a solution sa maju zhodovat na assignmentId
				if (solution.type && solution.type !== "solution") {
					alert('Nacitany subor je typu "' + solution.type + '" (ma byt "solution").');
					return;
				}

				if (!solution.assignmentId) {
					alert("Chyba ID zadania v rieseni.");
				}
				
				if (!currentAssignment || currentAssignment.id !== solution.assignmentId) {
					const matching = assignmentsLocal.find(a => a.id === solution.assignmentId);
					if (matching) {
						currentAssignment = matching;
						assignmentIndex = assignmentsLocal.indexOf(matching);
						await showAssignment(assignmentIndex);
					} 
					else {
						alert("Riesenie nepatri k ziadnemu nacitanemu zadaniu.");
						return;
					}
            	}

				if (assignmentType === 'avoid_cells') {
					const obstacles = solution.placements?.obstacles || [];
					if (!Array.isArray(obstacles)) {
						alert("V rieseni chybaju prekazky.");
						return;
					}
					//cleanObstaclesGrid();
					applyObstaclesFromSolution(obstacles);
					updateSolutionDiv();
					alert('Prekazky boli nacitane podla riesenia.');
				}
				else if (assignmentType === 'fastest_fill') {
					const sources = solution.placements?.waterSource || [];
					if (!Array.isArray(sources) || sources.length === 0) {
						alert("V rieseni chyba zdroj vody.");
						return;
					}

					console.log(sources);
					cleanWaterGrid();
					sources.forEach(([r, c]) => applyWaterSourceFromSolution(r, c));
					updateSolutionDiv();
					alert("Zdroj vody bol nacitany podla riesenia.");
				}

				syncStatesWithGrid();
            	simulationFinished[assignmentIndex] = false;

			} catch (error) {
				console.error(error);
				alert("Chyba pri nacitani riesenia: " + error.message);
			}
		};
		reader.readAsText(file);
	});


	//funkcia, ktora do mriezky prida prekazky na suradniciach z pola obstacles = [[r1,c1],[r2,c2],...]
	function applyObstaclesFromSolution(obstacles) {
		if (!Array.isArray(fixedObstacles[assignmentIndex])) {
        	fixedObstacles[assignmentIndex] = [];
    	}

		obstacles.forEach(([row, col]) => {
			if (row < 0 || row >= currentRows || col < 0 || col >= currentCols) return;
			gridArray[row][col] = 2;
			const cell = document.getElementById(`cell-${row}-${col}`);
			if (cell) {
				cell.className = "cell cellObstacle";
				cell.innerHTML = `<img src="icons/big.png" width="${cellSize}" height="${cellSize}">`;
			}
    	});

		//synchronizuj pomocne polia s aktualnym stavom mriezky
		syncStatesWithGrid();
	}

	//funkcia, ktora do mriezky prida jeden zroj vody na suradniciach [cellRow, cellCol]
	function applyWaterSourceFromSolution(cellRow, cellCol) {
		if (!Array.isArray(waterSource[assignmentIndex])) {
        	waterSource[assignmentIndex] = [];
    	}
		
		if (cellRow >= 0 && cellRow < currentRows && cellCol >= 0 && cellCol < currentCols) {
			gridArray[cellRow][cellCol] = 1;
			const cell = document.getElementById(`cell-${cellRow}-${cellCol}`);
			if (cell) {
				cell.className = "cell cellWater";
				cell.innerHTML = `<img src="icons/waterCell.png" width="${cellSize*0.7}" height="${cellSize*0.7}">`;
			}
			waterSource[assignmentIndex].push([cellRow, cellCol]);
    	}
		//synchronizuj interne polia
		syncStatesWithGrid();
	}

	//po kliknuti na "Spusti jeden krok" sa vykona jeden krok FloodFill algoritmu
	nextStepButton.addEventListener("click", () => nextStep());

	//po kliknuti na "Spusti program" sa zacne vykonavat algoritmus FloodFill a automaticky sa zmeni na stop button
	runButton.addEventListener("click", () => startSimulation());
	
	//po kliknuti na "Uloz riesenie" sa stiahne subor s nazvom UlohaN-riesenie.json, kde N je cislo ulohy
	saveButton.addEventListener("click", () => {
		//ziskaj udaje o aktualnej session (getSessionData() vytvori assignmentId, ak chybalo)
		const data = getSessionData();

		//ak nie je ziadne aktualne zadanie/solution, nedovolime ulozit 'null'
		if (!data) {
			alert('Nie je načítané žiadne zadanie alebo riešenie na uloženie.');
			return;
		}

		//preved do json formatu stringu
		const jsonString = JSON.stringify(data, null, 2);
		//prevod na json blob
		const blob = new Blob([jsonString], { type: "application/json" });

		//stiahnutie suboru: preferuj assignmentId obsiahnute v ulozenych datach
		const link = document.createElement("a");
		const url = URL.createObjectURL(blob);
		link.href = url;
		link.download = `Uloha${assignmentIndex + 1}-riesenie.json`;

		//pridaj do dokumentu pre lepsiu kompatibilitu (niektore prehliadace vyzaduju to)
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);

		URL.revokeObjectURL(url);
	});
	
	//po kliknuti "Dalsia uloha" sa prejde na dalsie zadanie
	nextButton.addEventListener("click", () => {
		if (assignments.length > 1) {
			saveCurrentStateToLocalStorage(assignmentIndex);
			saveSolution(assignmentIndex);
			assignmentIndex = (assignmentIndex + 1) % assignments.length;
			showAssignment(assignmentIndex);
			restoreSolutionFromDiv(assignmentIndex);

			const solutionDiv = document.getElementById("solutionDiv");
			if (!assignmentsLocal[assignmentIndex]?.solutionHTML) {
				// Skontroluj, či už bolo zadanie riešené
				if (assignmentsLocal[assignmentIndex]) {
					const assignment = assignmentsLocal[assignmentIndex];
					if (assignment.vyriesene) {
						document.getElementById("solutionDiv").innerHTML = "<span class='correct'>Zadanie už bolo vyriešené správne.</span>";
					} else if (assignment.pokusy > 0) {
						document.getElementById("solutionDiv").innerHTML = "<span class='incorrect'>Zadanie ešte nebolo vyriešené správne.</span>";
					} else {
						document.getElementById("solutionDiv").innerHTML = "<span class='incorrect'>Zadanie ešte nebolo riešené.</span>";
					}
				}
			}
			//cleanGrid();

			//deleteAllDivs();
			//simulationFinished[assignmentIndex] = false;
		}
	});

	function switchToLevelById(levelId) {
		if (assignmentIndex === -1) return; // Ak sa nenašlo zadanie s daným ID, ukonči funkciu
		if (assignments.length > 1) {
			saveCurrentStateToLocalStorage(assignmentIndex);
			//assignmentIndex = assignments.findIndex(assignment => assignment.id === levelId);
			saveSolution(assignmentIndex);

			assignmentIndex = levelId;

			showAssignment(assignmentIndex);
			
			restoreSolutionFromDiv(assignmentIndex);

			const solutionDiv = document.getElementById("solutionDiv");
			if (!assignmentsLocal[assignmentIndex]?.solutionHTML) {
				// Skontroluj, či už bolo zadanie riešené
				if (assignmentsLocal[assignmentIndex]) {
					const assignment = assignmentsLocal[assignmentIndex];
					if (assignment.vyriesene) {
						document.getElementById("solutionDiv").innerHTML = "<span class='correct'>Zadanie už bolo vyriešené správne.</span>";
					} else if (assignment.pokusy > 0) {
						document.getElementById("solutionDiv").innerHTML = "<span class='incorrect'>Zadanie ešte nebolo vyriešené správne.</span>";
					}
				}
			}

			//deleteAllDivs();
		}
	}

	//funkcia, ktora vyprazdni obsah vsetkych buniek v mriezke
	function deleteAllDivs() {
		const cells = document.querySelectorAll("#grid .cell");
		cells.forEach(cell => {
			cell.textContent = "";
		});
	}
	
	function saveCurrentStateToLocalStorage(index) {
		if (!currentAssignment) return;
		//uloz aktualny stav mriezky do aktualneho zadania
		assignmentsLocal[index].grid.gridState = gridArray.map(row => [...row]);
		
	}

	fileInput.addEventListener("change", (event) => {
	
		//vybrane jsonFiles
		const files = event.target.files;
		if (!files || files.length === 0) return;

		const promises = Array.from(files).map(file => {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => {
					try {
						const json = JSON.parse(reader.result);
						resolve({ json, fileName: file.name });
					} catch (error) {
						reject(error);
					}
				};
				reader.onerror = () => reject(reader.error);
				reader.readAsText(file);
			});
		});

		// pockam, kym su vsetky jsony precitane
		Promise.all(promises)
			//potom uloz nacitane subory do assignments pola
			.then(results => {
				assignments = [];
				results.forEach(({ json, fileName }) => {
					if (!json.id) json.id = generateAssignmentId();
					assignments.push(json);
					//console.log(`Nacitany subor ${fileName}:`, json);
				});
				//vycisti grid, ak je na nom voda alebo prekazky a ukaz prve zadanie
				cleanGrid();
				
				assignmentsLocal = assignments;
				assignmentsLocal.forEach(assignment => {
					assignment.vyriesene = 0;
					assignment.pokusy = 0;
				});

				//inicializacia potrebnych premennych na prazdne/false
				for (let i = 0; i < assignmentsLocal.length; i++) {
  					fillSteps[i] = {};
					waterSource[i] = [];
					initialGridSnapshot[i] = null;
					fixedObstacles[i] = [];
					simulationFinished[i] = false;
				}

				//console.log("nnNacitane zadania:", assignments);
				//console.log("nnassignmentsLocal:", assignmentsLocal);
				showAssignment(0);
				document.getElementById("progressTable").hidden = false;
				updateProgressTable();
				for(let i = 0; i < assignmentsLocal.length; i++) {
					stepsCounter[i] = 0;
					pokusyCounter[i] = 0;
				}
		})
		.catch(error => {
			console.error("Chyba pri nacitani json suborov:", error);
		});
	});
	
	// listenery na popup - ak sa klikne na info Button, tak sa otvori Popup
	openInfo.addEventListener("click", () => {
		modal.classList.add("open");
	});
	
	// ak sa klikne na X button v popupe, tak sa zatvori 
	closeInfo.addEventListener("click", () => {
		modal.classList.remove("open");
	});
	
	// QoL doplnky - ESC tlacitko zatvori popup okno
	document.addEventListener("keydown", e => {
		if(e.key === "Escape") modal.classList.remove("open");
	});
	
	// dizajn - oble okraje gridu
	function setRoundCorners(rows, cols) {
		const cells = document.querySelectorAll("#grid .cell");
		//ak nie su ziadne bunky, tak nic nerob
		if (!cells.length) return;
		
		let topLeft = cells[0];
		topLeft.style.borderTopLeftRadius = "10px";
		let topRight = cells[cols - 1]; 
		topRight.style.borderTopRightRadius = "10px";
		let bottomLeft = cells[cells.length - cols];
		bottomLeft.style.borderBottomLeftRadius = "10px";
		let bottomRight = cells[cells.length - 1];
		bottomRight.style.borderBottomRightRadius = "10px";
	}
	
	//dizajn - hrubsi okraj gridu
	function setOuterBorders(rows, cols) {
		const cells = document.querySelectorAll("#grid .cell");
		//ak nie su ziadne bunky, tak nic nerob
		if (!cells.length) return;
		
		cells.forEach((cell, index) => {
			const row = Math.floor(index / cols);
			const col = index % cols;
			
			if (row === 0) {
				cell.style.borderTopWidth = "3px";
			}
			if (row === rows - 1) {
				cell.style.borderBottomWidth = "3px";
			}
			if (col === 0) {
				cell.style.borderLeftWidth = "3px";
			}
			if (col === cols - 1) {
				cell.style.borderRightWidth = "3px";
			}
		});
	}
	
	let currentRows = 0;
	let currentCols = 0;

	//funkcia na vycistenie gridu - prenastavenie vsetkych buniek mriezky na "empty"
	function cleanGrid() {
		for (let i = 0; i < currentRows * currentCols; i++) {
			//najdenie prislusnej bunky
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			//vyprazdnenie nastavenim prislusnych classov
			cell.className = "cell cellEmpty";
			cell.innerHTML = "";
			
		}
		fillSteps[assignmentIndex] = {};
		waterSource[assignmentIndex] = [];
		//vycistenie mriezky aj interne (v 2D poli)
		initializeGridArray(currentRows, currentCols);
		//synchronizacia pomocnych poli s aktualnym stavom mriezky
		syncStatesWithGrid();
	}

	function cleanWaterGrid() {

		//zresetovanie prislusnych premennych drziacich info o vode
		waterCells = [];
		waterCount = 0;
		waterSource[assignmentIndex] = [];

		for (let i = 0; i < currentRows * currentCols; i++) {
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			if (cell.classList.contains("cellWater")) {
				//vyprazdnenie nastavenim prislusnych classov
				cell.className = "cell cellEmpty";
				cell.innerHTML = "";
				gridArray[cellRow][cellCol] = 0;
			}
		}
		// rebuild canonical auxiliary trackers
		syncStatesWithGrid();
	}

	function cleanObstaclesGrid() {

		//zresetovanie prislusnych premennych drziacich info o prekazkach
		obstacleCells = [];
		obstacleCount = 0;
		for (let i = 0; i < currentRows * currentCols; i++) {
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			if (cell.classList.contains("cellObstacle")) {
				//vyprazdnenie nastavenim prislusnych classov
				cell.className = "cell cellEmpty";
				cell.innerHTML = "";
				gridArray[cellRow][cellCol] = 0;
			}
		}
		//synchronizacia pomocnych poli s aktualnym stavom mriezky
		syncStatesWithGrid();
	}

	function setFreeMode() {
		//uchovaj si aktualny assignment type
		assignmentType = "free";
		//pri prepnuti na volny rezim sa vymazu zadania
		assignments = [];
		assignmentIndex = 0;
		assignmentsLocal = [];
		currentAssignment = null;
		initialGridSnapshot = [];
		//vycisti grid
		cleanGrid();
		//prenastav divs v task-div
		document.getElementById("levelCounter").innerHTML = "<p> Voľný režim </p>";
		document.getElementById("zadanieHeader").innerText = "";
		document.getElementById("task").innerHTML = "<p> Aktuálne sa nachádzate vo voľnom režime, v ktorom môžete do mriežky pridávať <u>prekážky</u> a <u>zdroje vody</u>. Pre načítanie zadaní úloh kliknite na tlačítko <b>Načítaj úlohy</b>.</p>";
		document.getElementById("solutionDiv").innerHTML = "";
		document.getElementById("progressTable").hidden = true;
		// schovaj buttony, ktore su v tomto rezime nepotrebne
		hideNonFreeButtons();
		syncStatesWithGrid();
		deleteAllDivs();
		waterSource = [];
		fillSteps = [];
		fixedObstacles = [];
		simulationFinished = [];
		generateGrid(8, 8);
	}

	function hideNonFreeButtons() {
		// v volnom rezime chceme len: Nacitaj, Jeden krok, Spusti/Zastav
		const toHide = [freeButtonDiv, loadSolutionButtonDiv, saveButtonDiv, nextButtonDiv, resetButtonDiv];

		for (let i = 0; i < toHide.length; i++) {
			if (toHide[i]) toHide[i].style.display = "none";
		}

		// buttony ktore su v tomto rezime potrebne
		loadButtonDiv.style.display = '';
		nextStepButtonDiv.style.display = '';
		runButtonDiv.style.display = '';
		cleanButtonDiv.style.display = '';
		cleanWaterButtonDiv.style.display = '';
		cleanObstaclesButtonDiv.style.display = '';
		addWaterIconDiv.style.display = '';
		addObstacleIconDiv.style.display = '';
		adjustRowsButtonsDiv.style.display = '';
		adjustColumnsButtonsDiv.style.display = '';

	}

	function showNonFreeButtons() {
		const toShow = [freeButtonDiv, saveButtonDiv, nextButtonDiv, resetButtonDiv];
		for (let i = 0; i < toShow.length; i++) {
			if (toShow[i]) toShow[i].style.display = "";
		}
	}

	let waterCount = 0;
	let emptyCount = 0;


	//pridanie vody do bunky [cellRow, cellCol], respektive jej odstranenie, ak v nej voda uz je
	function handleLeftClick(cell, cellRow, cellCol) {

		if (simulationFinished[assignmentIndex]) return;

		//pri zadani typu "avoid_cells" sa nemoze pridavat voda
		if (assignmentType === "avoid_cells") return;

		//ak uz je v bunke voda, tak vyprazdni bunku
		if (gridArray[cellRow][cellCol] === 1) {
			waterCount = waterCount - 1;
			gridArray[cellRow][cellCol] = 0;
			cell.className = "cell cellEmpty";
			cell.innerHTML = "";
			// remove from waterCells
			let index = waterCells.indexOf(cell);
			if (index != -1) waterCells.splice(index, 1);
			// add to empty trackers
			emptyCount = emptyCount + 1;
			emptyCells.push(cell);
			//if (assignmentType !== "free") 
			waterSource[assignmentIndex] = waterSource[assignmentIndex].filter(([r, c]) => r !== cellRow || c !== cellCol);
		}
		//inak tam pridaj vodu
		else {
			//pri zadani typu "fastest_fill" je pocet policok vody obmedzeny na jedno
			if (assignmentType === "fastest_fill" && (waterSource[assignmentIndex].length >= currentAssignment.goal.allowedSources || cell.classList.contains("cellObstacle"))) return;
			waterCount = waterCount + 1;
			gridArray[cellRow][cellCol] = 1;
			cell.className = "cell cellWater";
			const iconSize = cellSize * 0.7;
			cell.innerHTML = `<img src="icons/waterCell.png" class="icon" width="${iconSize}" height="${iconSize}">`;
			waterCells.push(cell);
			//if (assignmentType !== "free") 
			if (!Array.isArray(waterSource[assignmentIndex])) waterSource[assignmentIndex] = [];
			waterSource[assignmentIndex].push([cellRow, cellCol]);
			// remove from empty trackers if present
			//emptyCount = emptyCount - 1;
			//let index = emptyCells.indexOf(cell);
			//if (index != -1) emptyCells.splice(index, 1);

		}
		syncStatesWithGrid();
		updateSolutionDiv();
	}

	let obstacleCount = 0;

	//pridanie prekazky do bunky [cellRow, cellCol], respektive jej odstranenie, ak v nej prekazka uz je
	function handleRightClick(cell, cellRow, cellCol) {

		if (simulationFinished[assignmentIndex]) return;

		//pri zadani typu "fastest_fill" sa do mriezky nepridavaju prekazky
		if (assignmentType === "fastest_fill") return;

		const obstaclesFixedForThisAssignment = fixedObstacles[assignmentIndex] || [];
		const isFixed = obstaclesFixedForThisAssignment.some(([r, c]) => r === cellRow && c === cellCol);

		if (isFixed) return;

		//ak uz je v bunke prekazka, tak vyprazdni bunku
		if (gridArray[cellRow][cellCol] === 2) {
			obstacleCount = obstacleCount - 1;
			gridArray[cellRow][cellCol] = 0;
			cell.className = "cell cellEmpty";
			cell.innerHTML = "";
			// remove from obstacleCells
			let index = obstacleCells.indexOf(cell);
			if (index != -1) obstacleCells.splice(index, 1);
			// add to empty trackers
			emptyCount = emptyCount + 1;
			emptyCells.push(cell);
		}


		//inak tam pridaj prekazku
		else {
			//pri zadani typu "avoid_cells" je obmedzeny pocet prekazok v mriezke na .goal.maxNumOfObstacles
			if (currentAssignment && obstacleCount >= currentAssignment.goal.maxNumOfObstacles) return;
			if (waterSource[assignmentIndex] && waterSource[assignmentIndex].some(([r, c]) => r === cellRow && c === cellCol)) {
				waterSource[assignmentIndex] = waterSource[assignmentIndex].filter(([r, c]) => r !== cellRow || c !== cellCol);
			}
			obstacleCount = obstacleCount + 1;
			gridArray[cellRow][cellCol] = 2;
			cell.className = "cell cellObstacle";
			const iconSize = cellSize * 1;
			cell.innerHTML = `<img src="icons/big.png" class="icon" width="${iconSize}" height="${iconSize}">`;
			obstacleCells.push(cell);
			// remove from empty trackers if present
			//emptyCount = emptyCount - 1;
			//let index = emptyCells.indexOf(cell);
			//if (index != -1) emptyCells.splice(index, 1);
		}
		syncStatesWithGrid();
		updateSolutionDiv();
	}
	
	const grid = document.getElementById("grid");

	let preserveGrid = false;

	//funkcia na vytvorenie mriezky rozmerov [riadky, stlpce], sizePolicka je velkost jednej bunky/stvorceka
	//zaklad 8x8
	function generateGrid(rows, cols) {
		
		currentRows = rows;
		currentCols = cols;
		
		if (!preserveGrid) initializeGridArray(currentRows, currentCols);

		const grid = document.getElementById("grid");
		
		grid.innerHTML = "";
		
		//velkost mriezky - aby sa to zmestilo na obrazovku bez scrollovania
		const maxGridSize = Math.min(window.innerWidth, window.innerHeight) * 0.5;
		
		//dynamicky zmenit velkost bunky v zavislosti od poctu riadkov/stlpcov
		cellSize = Math.floor(maxGridSize/currentRows);
		//najvacsia velkost bunky
		if (cellSize > 80) cellSize = 80;
		
		// nastavenie poctu stlpcov a velkost bunky
		grid.style.gridTemplateColumns = "repeat(" + currentCols + ", " + cellSize + "px)";
  
		// nastavenie poctu riadkov a velkost bunky
		grid.style.gridTemplateRows = "repeat(" + currentRows + ", " + cellSize + "px)";
		
		//console.log(currentRows);
		//console.log(currentCols);

		//vytvorenie buniek
		for (let i = 0; i < currentRows * currentCols; i++) {
			let cell = document.createElement("div");
			cell.classList.add("cell", "cellEmpty"); // defaultne je bunka prazdna, pridanie class="cellEmpty" (two-class approach)
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			cell.id = `cell-${cellRow}-${cellCol}`; // id v tvare cell-row-col
			cell.addEventListener("click", () => handleLeftClick(cell, cellRow, cellCol));
			cell.addEventListener("contextmenu", (e) => {
				e.preventDefault();
				handleRightClick(cell, cellRow, cellCol);
			});
			grid.appendChild(cell);
		}
		
		//funkcia na oble okraje mriezky
		setRoundCorners(currentRows, currentCols);
		
		//funkcia na hrubsie vonkajsie okraje mriezky
		setOuterBorders(currentRows, currentCols);

		//defaultne v volnom rezime
		hideNonFreeButtons();

		//synchronizacia pomocnych poli s aktualnym stavom mriezky
		//console.log("Generating grid and syncing states:");
		if (!preserveGrid) syncStatesWithGrid();

		updateGridInfo();
	}
	
	//ak nie je nacitane zadanie, vykresli defaultny grid 8x8
	if (assignmentType === "free" || assignmentType === null || currentAssignment === null) generateGrid(8,8);
	else generateGrid(currentAssignment.grid.rows, currentAssignment.grid.cols);

	//funkcia, ktora sa vyuziva pri pridavani riadkov/stlpcov na prekreslenie aktualneho obsahu mriezku na "novu" - vacsiu/mensiu podla akcii pouzivatela
	function redrawGridPreservingContent() {
		const snapshot = gridArray.map(row => [...row]);
		const cellRows = snapshot.length;
		const cellCols = snapshot[0].length;
		generateGrid(cellRows, cellCols);
		gridArray = snapshot;

		for (let row = 0; row < cellRows; row++) {
			for (let col = 0; col < cellCols; col++) {
				const val = gridArray[row][col];
				const cell = document.getElementById(`cell-${row}-${col}`);
				if (!cell) continue;

				if (val === 1) {
					cell.className = "cell cellWater";
					if (waterSource[assignmentIndex] && waterSource[assignmentIndex].some(([r, c]) => r === row && c === col)) {
						iconSize = cellSize * 0.7;
						cell.innerHTML = `<img src="icons/waterCell.png" class="icon" width="${iconSize}" height="${iconSize}">`;
					}
				} else if (val === 2) {
					cell.className = "cell cellObstacle";
					iconSize = cellSize * 1;
					cell.innerHTML = `<img src="icons/big.png" class="icon" width="${iconSize}" height="${iconSize}">`;
				} else {
					cell.className = "cell cellEmpty";
					cell.innerHTML = "";
				}
			}
		}
		syncStatesWithGrid();
	}

	//funkcia, ktora zabezpecuje dynamicke zobrazovanie poctu riadkov a stlpcov pod gridom
	function updateGridInfo() {
		const rows = gridArray.length;
		const cols = gridArray[0].length;
		document.getElementById("rowCountLabel").textContent = `Riadky: ${rows}`;
		document.getElementById("colCountLabel").textContent = `Stĺpce: ${cols}`;
		
	}

	//funkcia na pridanie riadka
	function addRow() {
		preserveGrid = true;
		gridArray.push(Array(currentCols).fill(0));
		currentRows++;
		redrawGridPreservingContent();
		preserveGrid = false;
		updateGridInfo();
	}

	//funkcia na odstranenie riadka
	function removeRow() {
		if (currentRows <= 1) return;
		preserveGrid = true;
		gridArray.pop();
		currentRows--;
		redrawGridPreservingContent();
		preserveGrid = false;
		updateGridInfo();
	}

	//funkcia na pridanie stlpca
	function addColumn() {
		preserveGrid = true;
		gridArray.forEach(row => row.push(0));
		currentCols++;
		redrawGridPreservingContent();
		preserveGrid = false;
		updateGridInfo();
	}

	//funkcia na odstranenie stlpca
	function removeColumn() {
		if (currentCols <= 1) return;
		preserveGrid = true;
		gridArray.forEach(row => row.pop());
		currentCols--;
		redrawGridPreservingContent();
		preserveGrid = false;
		updateGridInfo();
	}


	function nextStep() {
		//kopia mriezky, aby nova voda neovplyvnila fill
		let newGridArray = gridArray.map(arr => [...arr]);

		//boolean trackujuci zmenu v mriezke
		let changed = false;
		//console.log("assignmentType:", assignmentType);
		// Prejdi všetkými krajnými políčkami, ktoré sú == 0
		if (assignmentType == 'avoid_cells') {
			for (let row = 0; row < gridArray.length; row++) {
				for (let col = 0; col < gridArray[row].length; col++) {
					// Skontroluj, či je políčko na kraji a zároveň prázdne (== 0)
					if ((row === 0 || row === gridArray.length - 1 || col === 0 || col === gridArray[row].length - 1) && gridArray[row][col] === 0) {
						// Pridaj do tej bunky vodu (1)
						newGridArray[row][col] = 1;
						// Nastala zmena v mriezke
						changed = true;
						// Prenastav div bunky aj na stránke
						const newWaterCell = document.getElementById(`cell-${row}-${col}`);
						newWaterCell.classList.remove("cellEmpty");
						newWaterCell.classList.add("cellWater");
						// Iba ak ešte nie je v zozname waterCells (ochrana proti duplikátom)
						if (!waterCells.includes(newWaterCell)) {
							waterCount = waterCount + 1;
							waterCells.push(newWaterCell);
							emptyCount = emptyCount - 1;
							let index = emptyCells.indexOf(newWaterCell);
							if (index != -1) emptyCells.splice(index, 1);
						}
					}
				}
			}
		}
		// floodfill algoritmus
		for (let row = 0; row < gridArray.length; row++) {
			for (let col = 0; col < gridArray[row].length; col++) {
				//ak je v bunke voda, tak sa rozsiruj do susedov, voda = 1
				if (gridArray[row][col] === 1) {
					//susedia bunky cell = [row][col]
					const neighbours = [
						[row - 1, col], //horny sused
						[row + 1, col], //dolny sused
						[row, col - 1], //lavy sused
						[row, col + 1] //pravy sused
					];
					
					neighbours.forEach(([nRow, nCol]) => {
						//ak je riadok suseda v rozsahu mriezky
						if (nRow >= 0 && nRow < gridArray.length 
						// a zaroven ak je stlpec suseda v rozsahu mriezky
						&& nCol >= 0 && nCol < gridArray[row].length
						//a zaroven ak je bunka [nRow][nCol] prazdna v povodnej mriezke (0)
						&& gridArray[nRow][nCol] === 0
						// a zaroven nebola este oznacena ako nova voda v tejto iteracii
						&& newGridArray[nRow][nCol] === 0) {
							//pridaj do tej bunky vodu (1)
							newGridArray[nRow][nCol] = 1;
							//nastala zmena v mriezke
							changed = true;
							//prenastav div bunky aj na stranke
							const newWaterCell = document.getElementById(`cell-${nRow}-${nCol}`);
							newWaterCell.classList.remove("cellEmpty");
							newWaterCell.classList.add("cellWater");

							if (assignmentType === "fastest_fill") {
								if (!newWaterCell.textContent) {
									newWaterCell.textContent = stepsCounter[assignmentIndex] + 1; // krok sa zobrazuje ako krok+1, lebo krok 0 je povodny stav
									fillSteps[assignmentIndex][`${nRow},${nCol}`] = stepsCounter[assignmentIndex];
								}
							}
							// iba ak este nie je v zozname waterCells (ochrana proti duplikatom)
							if (!waterCells.includes(newWaterCell)) {
								waterCount = waterCount + 1;
								waterCells.push(newWaterCell);
								emptyCount = emptyCount - 1;
								let index = emptyCells.indexOf(newWaterCell);
								if (index != -1) emptyCells.splice(index, 1);
							}
						}
					});
				}
			}
		}

		//prekopiruj novu mriezku do globalneho pola pre mriezku
		gridArray = newGridArray;


		//ak sa nic do mriezky nepridalo, tak ukonci simulaciu
		if (!changed) {
			stopSimulation();
			// verifikuj vysledok 
			verifyAfterSimulation();
			if (assignmentType !== "free") {
				simulationFinished[assignmentIndex] = true;
			}
		}
		else {
			stepsCounter[assignmentIndex]++;
			updateSolutionDiv();
		}
	}
	
	//window.addEventListener("resize", () => generateGrid());

	//nastavenie stavu buttonu (toggle = true-enabled/false-disabled)
	function setButtonState(buttonId, toggle) {
		if (!buttonId) return;
		const button = document.getElementById(buttonId);
		//buttony mozu byt v button-wrapper alebo v sidebar-button-wrapper (column vs row rozlozenie button-label)
		let wrapper = button.closest(".button-wrapper") || button.closest(".sidebar-button-wrapper") || button.closest(".sidebar-button-wrapper-double");

		//ak je toggle = true, tak enable button-label
		if (toggle) {
			button.disabled = false;
			wrapper.classList.remove("disabled");
		//inak disable
		} else {
    		button.disabled = true;
			wrapper.classList.add("disabled");
 		}
	}

	let simulationInterval;
	let stepsCounter = [];
	let pokusyCounter = [];

	//funkcia na spustenie algoritmu FloodFillu
	function startSimulation() {

		if (assignmentType === "fastest_fill") {
			const allowedSources = currentAssignment.goal.allowedSources;
			if (!waterSource[assignmentIndex] || waterSource[assignmentIndex].length == 0) {
				alert("Pridajte zdroj vody do mriežky na spustenie programu.");
				return;
			}
			if (waterSource[assignmentIndex].length > allowedSources) {
				alert(`Počet vodných zdrojov (${waterSource[assignmentIndex].length}) prekročil povolený limit (${allowedSources}).\nStlačte tlačidlo začni odznova.`);
				return;
			}
		}
		//vypni vsetky zvysne buttony, ked prebieha algoritmus
		setButtonState("freeButton", false);
		setButtonState("loadButton", false);
		setButtonState("loadSolutionButton", false);
		setButtonState("nextStepButton", false);
		setButtonState("resetButton", false);
		setButtonState("cleanButton", false);
		setButtonState("cleanWaterButton", false);
		setButtonState("cleanObstaclesButton", false);
		setButtonState("addRowsButton", false);
		setButtonState("addColumnsButton", false);
		setButtonState("removeRowsButton", false);
		setButtonState("removeColumnsButton", false);
		setButtonState("saveButton", false);
		setButtonState("nextButton", false);

		if (assignmentType !== "free" && assignmentsLocal[assignmentIndex] && assignmentsLocal[assignmentIndex].vyriesene === 0) {
			assignmentsLocal[assignmentIndex].pokusy = (assignmentsLocal[assignmentIndex].pokusy || 0) + 1;
			updateProgressTable();
		}

		//zmen run button na stop button
		document.getElementById("runButtonDiv").innerHTML = '<button type="button" class="button" id="stopButton" onclick="stopSimulation()"><img src="icons/stop.png" class="icon" width="50px" height="50px"></button><span class="label" id="stopLabel"> Stopni program </span>';

		//kazdych 0.5sekundy sa vykona jeden krok floodfill algoritmu
		simulationInterval = setInterval(() => {
			nextStep();
		}, 500);
		
	}

	//funkcia na zastavenie algoritmu FloodFillu
	function stopSimulation() {
		//znovu zapne vsetky zvysne buttony, pretoze sa stopol algoritmus 
		setButtonState("freeButton", true);
		setButtonState("loadButton", true);
		setButtonState("loadSolutionButton", true);
		setButtonState("nextStepButton", true);
		setButtonState("resetButton", true);
		setButtonState("cleanButton", true);
		setButtonState("cleanWaterButton", true);
		setButtonState("cleanObstaclesButton", true);
		setButtonState("addRowsButton", true);
		setButtonState("removeRowsButton", true);
		setButtonState("addColumnsButton", true);
		setButtonState("removeColumnsButton", true);
		setButtonState("saveButton", true);
		setButtonState("nextButton", true);

		//zmen stop button na run button
		document.getElementById("runButtonDiv").innerHTML = '<button type="button" class="button" id="runButton" onclick="startSimulation()"><img src="icons/play-button.png" class="icon" width="50px" height="50px"></button><span class="label" id="runLabel"> Spusti program </span>';
		if (simulationInterval) {
			clearInterval(simulationInterval);
			simulationInterval = null;
		}
		
		
		//updateProgressTable();
	}

	//funkcia, ktora zabezpecuje zapamatanie obsahu solutionDiv pre prislusne zadanie s indexom index
	function saveSolution(index) {
		const div = document.getElementById("solutionDiv");
		if (div) assignmentsLocal[index].solutionHTML = div.innerHTML;
	}

	//funkcia, ktora zabezpecuje spatne nacitanie obsahu solutionDiv pre prislusne zadanie s indexom index
	function restoreSolutionFromDiv(index) {
		const div = document.getElementById("solutionDiv");
		if (div && assignmentsLocal[index].solutionHTML) {
			div.innerHTML = assignmentsLocal[index].solutionHTML;
		}
	}

	// kontrola riesenia po ukonceni simulacie
	function verifyAfterSimulation() {
		if (!currentAssignment) return;
		syncStatesWithGrid();

		//ak je zadanie "avoid_cells" tak skontroluj, ci je pocet suchych policok numOfEmptyCells rovnaky ako v cieli a ci je pocet prekazok vacsi ako maxNumOfObstacles
		if (assignmentType === "avoid_cells") {
			const numEmptyCells = currentAssignment.goal && currentAssignment.goal.numOfEmptyCells;
			const maxObstacles = currentAssignment.goal && currentAssignment.goal.maxNumOfObstacles;
			//ak pocet suchych buniek nie je dobre definovany, tak nic nerob
			if (typeof numEmptyCells !== "number") return;

			//celkovy pocet buniek v mriezke
			const totalCells = currentRows * currentCols;
			//pocet suchych buniek zalozeny na internom counteri
			const dry = totalCells - waterCount - obstacleCount;
			//ak sa rovna ciel s tym, co mame tak ok = true, inak false
			let ok = (dry === numEmptyCells);

			//ak je maxObstacles definovane, tak ok je true len ak je splnena aj tato podmienka (interne pocitane prekazky su mensie ako max)
			if (typeof maxObstacles === "number") ok = ok && (obstacleCount <= maxObstacles);

			let html = ok ? "<span class='correct'>Riešenie je správne.</span>" : "<span class='incorrect'>Riešenie nie je správne.</span><br>";
			html = html + `<br> <span class='details'>Suché políčka: <strong  style='font-size: 24px;'>${dry}</strong>/${numEmptyCells}.<br> Prekážky: <strong style='font-size: 24px;'>${obstacleCount}</strong>${typeof maxObstacles==="number" ? "/" + maxObstacles + "" : ""}.</span>`;
			document.getElementById("solutionDiv").innerHTML = html;

			if (ok) {
				assignmentsLocal[assignmentIndex].vyriesene = 1;
				updateProgressTable();
			}
		}

		if (assignmentType === "fastest_fill") {
			//v fastest_fill je riesenie spravne, ak je vsetka voda rozlita (teda v mriezke nie je ziadna prazdna bunka)

			let ok = (waterCount + obstacleCount === currentRows * currentCols);
			//if (currentAssignment.goal && typeof currentAssignment.goal.maxSteps === "number") {
			if (ok && waterSource[assignmentIndex].length === currentAssignment.goal.allowedSources && stepsCounter[assignmentIndex] <= currentAssignment.goal.maxSteps) {
				document.getElementById("solutionDiv").innerHTML = `<span class='correct'>Riešenie je správne.</span><br><span class='details'>Počet zdrojov vody: <strong style='font-size: 24px;'>${waterSource[assignmentIndex].length}</strong>/${currentAssignment.goal.allowedSources}.</span><br><span class='details'>Počet krokov: <strong style='font-size: 24px;'>${stepsCounter[assignmentIndex]}</strong>/${currentAssignment.goal.maxSteps}.</span>`;
				assignmentsLocal[assignmentIndex].vyriesene = 1;
				updateProgressTable();
			} 
			else if (ok && stepsCounter[assignmentIndex] > currentAssignment.goal.maxSteps) {
				document.getElementById("solutionDiv").innerHTML = `<span class='incorrect'>Riešenie nie je správne, pretože bol prekročený počet krokov.</span><br><span class='details'>Počet krokov: <strong style='font-size: 24px;'>${stepsCounter[assignmentIndex]}</strong>/${currentAssignment.goal.maxSteps}.</span>`;
			} 
			else {
				document.getElementById("solutionDiv").innerHTML = `<span class='incorrect'>Riešenie nie je správne.</span><br><span class='details'>Počet krokov: <strong style='font-size: 24px;'>${stepsCounter[assignmentIndex]}</strong>/${currentAssignment.goal.maxSteps}.</span>`;
			}
		}
	}

	function generateTextAvoidCells() {
		if (!currentAssignment) return "";
		let text = `Vašim cieľom je pridať prekážky do mriežky tak, aby voda nezaplavila presne <span class="details" style="font-size: 24px;">${currentAssignment.goal.numOfEmptyCells}</span> ${currentAssignment.goal.numOfEmptyCells === 1 ? 'suché políčko' : (currentAssignment.goal.numOfEmptyCells >= 2 && currentAssignment.goal.numOfEmptyCells <= 4 ? 'suché políčka' : 'suchých políčok')}. Použite maximálne <span class="details" style="font-size: 24px;">${currentAssignment.goal.maxNumOfObstacles}</span> ${currentAssignment.goal.maxNumOfObstacles === 1 ? 'prekážku' : (currentAssignment.goal.maxNumOfObstacles >= 2 && currentAssignment.goal.maxNumOfObstacles <= 4 ? 'prekážky' : 'prekážok')}.\n\n`;
		
		//Minimálny počet prekážok je ${currentAssignment.goal.minNumOfObstacles}.\n\n`;
		/*text += "Pravidlá:\n";
		text += "- Prekážky sa pridávajú pravým kliknutím na bunku.\n";
		text += "- Počet prekážok musí byť minimálne " + currentAssignment.goal.minNumOfObstacles + ".\n";
		text += "- Počet suchých políčok musí byť presne " + currentAssignment.goal.numOfEmptyCells + ".\n";
		text += "- Voda sa automaticky rozleje z okrajových políčok.\n";
		text += "- Môžete spustiť simuláciu, ktorá ukáže, ako sa voda rozleje.\n";
		text += "- Po skončení simulácie sa zobrazí, či je riešenie správne.\n";*/
		return text;
	}

	function generateTextFastestFill() {
		if (!currentAssignment) return "";
		let allowedSources = currentAssignment.goal.allowedSources; 
		let sourceText = allowedSources === 1 ? 'zdroj vody' : (allowedSources >= 2 && allowedSources <= 4 ? 'zdroje vody' : 'zdrojov vody');
		let text = `Vašim cieľom je pridať <span class="details" style="font-size: 24px;">${allowedSources}</span> ${sourceText} do mriežky tak, aby sa voda rozliala do všetkých políčok čo najrýchlejšie.</span><br>`;
		text += `Povolený počet krokov: <span class="details" style="font-size: 24px;">${currentAssignment.goal.maxSteps}</span>.\n`;
		/*text += "Pravidlá:\n";
		text += "- Zdroj vody sa pridáva ľavým kliknutím na bunku.\n";
		text += "- Môžete pridať len jeden zdroj vody.\n";
		text += "- Voda sa rozleje zo zdroja do všetkých susedných políčok.\n";
		text += "- Môžete spustiť simuláciu, ktorá ukáže, ako sa voda rozleje.\n";
		text += "- Po skončení simulácie sa zobrazí, či je riešenie správne.\n";*/
		return text;
	}

	//funkcia, ktora sa pouziva na dynamicke menenie obsahu solutionDiv
	function updateSolutionDiv() {
		if (assignmentType === "avoid_cells") {
			const numEmptyCells = currentAssignment.goal?.numOfEmptyCells ?? 0;
        	const maxObstacles = currentAssignment.goal?.maxNumOfObstacles ?? 0;
			
			//celkovy pocet buniek v mriezke
        	const totalCells = currentRows * currentCols;
			//pocet suchych buniek zalozeny na internom counteri
        	const dry = totalCells - waterCount - obstacleCount;
			document.getElementById("solutionDiv").innerHTML = `<br><span class='details'>Suché políčka: <strong  style='font-size: 24px;'>${dry}</strong>/${numEmptyCells}.<br>Prekážky: <strong style='font-size: 24px;'>${obstacleCount}</strong>${typeof maxObstacles==="number" ? "/" + maxObstacles + "" : ""}.</span>`;
		}
		else if (assignmentType === "fastest_fill") {
			const allowedSources = currentAssignment.goal?.allowedSources ?? 0;
        	const waterSources = Array.isArray(waterSource?.[assignmentIndex]) ? waterSource[assignmentIndex].length : 0;
        	const steps = typeof stepsCounter?.[assignmentIndex] === "number" ? stepsCounter[assignmentIndex] : 0;
        	const maxSteps = currentAssignment.goal?.maxSteps ?? 0;
			document.getElementById("solutionDiv").innerHTML = `<br><span class='details'>Počet zdrojov vody: <strong  style='font-size: 24px;'>${waterSources}</strong>/${allowedSources}.<br>Počet krokov: <strong style='font-size: 24px;'>${steps}</strong>/${maxSteps}.</span>`;
		}
	}

	updateSolutionDiv();

	//funkcia na debug
	function debug() {
		console.log("assignments");
		console.log(assignments);
		console.log("assignmentsLocal");
		console.log(assignmentsLocal);
		console.log("assignmentIndex");
		console.log(assignmentIndex);
		console.log("assignmentType");
		console.log(assignmentType);
		console.log("currentAssignment");
		console.log(currentAssignment);
		console.log("initialGridSnapshot");
		console.log(initialGridSnapshot);
		console.log("gridArray");
		console.log(gridArray);
		console.log("waterCells");
		console.log(waterCells);
		console.log("waterCount");
		console.log(waterCount);
		console.log("obstacleCells");
		console.log(obstacleCells);
		console.log("obstacleCount");
		console.log(obstacleCount);
		console.log("emptyCells");
		console.log(emptyCells);
		console.log("emptyCount");
		console.log(emptyCount);
		console.log("waterSource");
		console.log(waterSource);
		//console.log("waterSource.length");
		//console.log(waterSource.length);
		console.log("fillSteps");
		console.log(fillSteps);
		console.log("fixedObstacles");
		console.log(fixedObstacles);
		console.log("simulationFinished");
		console.log(simulationFinished);
	}
</script>
</body>
</html>

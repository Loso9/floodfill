<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title> Ako tečie voda </title>
	<link rel="icon" href="icons/water.png" type="image/png">
	<link href="style.css" rel="stylesheet" />
</head>
<body>

<!-- V headeri sa nachadza primarne button o informaciach o projekte -->
<header>
	<!-- Button "Informacie" -->
	<div class="button-wrapper">
		<button type="button" class="button" title="Informácie o stránke" id="openModal"> 
			<img src="icons/information.png" class="icon" width="50px" height="50px"> 
		</button>
		<span class="label" id="infoLabel"> Informácie </span>
	</div>
	
	<!-- Popup okno, ktore sa otvori po kliknuti na Button "Informacie" -->
	<div class="modal" id="modal">
			<div class="modal-inner">
				
				<!-- Button Zatvor Popup -->
				<div class="button-wrapper">
					<button type="button" class="button" title="Informácie o stránke" id="closeModal"> 
						<img src="icons/close.png" class="icon" width="25px" height="25px"> 
					</button>
				</div>
				
				<!-- Text popupu -->
				<h2> Projekt - Ako tečie voda </h2>
				<p> 
				Projekt <i>Ako tečie voda </i> je inšpirovaný algoritmom <b>FloodFill</b>. V tomto softvéri má užívateľ k dispozícií dva 
				režijné módy - hra a tvorba. V režime "hra" má používateľ možnosť riešiť úlohy na mriežke, týkajúce sa spomínaného algoritmu.
				Vzhľadom na zadanie môže používateľ v móde <i> Experimentuj </i> (ikona pera) pridávať prekážky; určovať, odkiaľ sa má 
				začať liať voda; označovať štvorčeky, kam sa, podľa neho, voda nedostane; prípadne do štvorčekov vkladať čísla určujúce 
				poradie zaplavenia vodou. 
				</p>
				<div id="linkSpecifikacia">
					<a href="specs.pdf"> Špecifikácia projektu </a>
				</div>
				<div id="linkGithub">
					<a href=https://github.com/Loso9/floodfill> GitHub repozitár </a>
			</div>
		</div>
</header>

<!-- Nadpisy -->
<h1> Ako tečie voda</h1>
<h2> Marek Lošonský, Martin Hošek </h2>

<!-- Div na rezimy hry -->
<div class="mode-switch">
	<span id="mode-hra" class="active"> HRA </span>
	<span id="mode-tvorba"> TVORBA </span>
</div>


<!-- Seria Buttonov pre herny rezim -->
<div id="hra-buttony">
	<div class="button-bar">
		<!-- zatial nevyuzity button Zadanie 
		<div class="button-wrapper">
			<button type="button" class="button" title="Zobraz zadanie"> 
				<img src="icons/quest.png" class="icon" width="40px" height="40px"> 
			</button>
			<span class="label" id="zadanieLabel"> Zadanie </span>
		</div> 
		-->
		<div class="button-wrapper" id="freeButtonDiv">
			<button type="button" class="button" id="freeButton"> 
				<img src="icons/free.png" class="icon" width="50px" height="50px"> 
			</button>
			<span class="label" id="freeLabel"> Voľný režim </span>
		</div>
		<div class="button-wrapper" id="loadButtonDiv">
			<button type="button" class="button" id="loadButton"> 
				<img src="icons/load.png" class="icon" width="50px" height="50px"> 
			</button>
			<!-- neviditelny input element pre filepicker -->
			<input type="file" multiple id="fileInput" accept=".json" style="display: none;"/>
			<span class="label" id="loadLabel"> Načítaj úlohy </span>
		</div>
		<div class="button-wrapper" id="loadSolutionButtonDiv" style="display: none;">
			<button type="button" class="button" id="loadSolutionButton"> 
				<img src="icons/upload.png" class="icon" width="50px" height="50px"> 
			</button>
			<!-- neviditelny input element pre filepicker -->
			<input type="file" id="solutionFileInput" accept=".json" style="display: none;"/>
			<span class="label" id="loadSolutionLabel"> Načítaj riešenie </span>
		</div>
		<div class="button-wrapper" id="nextStepButtonDiv">
			<button type="button" class="button" id="nextStepButton"> 
				<img src="icons/one.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="nextStepLabel"> Spusti jeden krok </span>
		</div>
		<div class="button-wrapper" id="runButtonDiv">
			<button type="button" class="button" id="runButton">
				<img src="icons/play-button.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="runLabel"> Spusti program </span>
		</div>
		<div class="button-wrapper" id="saveButtonDiv">
			<button type="button" class="button" id="saveButton">
				<img src="icons/save.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="ulozLabel"> Ulož riešenie </span>
		</div>
		<div class="button-wrapper" id="nextButtonDiv">
			<button type="button" class="button" id="nextButton">
				<img src="icons/arrow.png" class="icon" width="50px" height="50px">
			</button>
			<span class="label" id="dalejLabel"> Ďalšia úloha </span>
		</div>
	</div>
</div>

<div class="progressTable" id="progressTable">
	<table>
		<tr>
			<td>#</td>
		</tr>
		<tr>
			<td>Typ (AC/FF)</td>
		</tr>
		<tr>
			<td>Počet pokusov</td>
		</tr>
		<tr>
			<td>Status (krížik/fajka)
			</td>
		</tr>
	</table>
</div>

<!-- Div v ktorom bude jednak mriezka (vlavo) a zadanie (vpravo), !!! a extra buttony podla zadania vlavo -->
<div id="hra-section">
	<div id="task-wrapper">
		<div id="levelCounter">
			<p> Voľný režim </p>
		</div>
		<h3 id="zadanieHeader"> Zadanie </h3>
		<div id="task">
			<p> 
			Aktuálne sa nachádzate vo voľnom režime, v ktorom môžete do mriežky pridávať <u>prekážky</u> a <u>zdroje vody</u>. 
			Pre načítanie zadaní úloh kliknite na tlačítko <b>Načítaj úlohy</b>.
			</p>
		</div>
		<div id="solutionDiv"> </div> 
	</div>
	<div id="sidebar-grid">
		<div id="grid"> </div>
		<div id="sidebar">
			<div id="sidebar-top">
				<span class="label" id="helperLabel"> Nástroje </span>
				<div class="sidebar-button-wrapper" id="cleanButtonDiv">
					<button type="button" class="button" id="cleanButton"> 
						<img src="icons/clean.png" class="icon" width="40px" height="40px">
					</button>
					<span class="label" id="cleanLabel"> Vyčisti mriežku </span>
				</div>
				<div class="sidebar-button-wrapper" id="cleanWaterButtonDiv">
					<button type="button" class="button" id="cleanWaterButton"> 
						<img src="icons/delete-water.png" class="icon" width="40px" height="40px">
					</button>
					<span class="label" id="cleanWaterLabel"> Odstráň vodu </span>
				</div>
				<div class="sidebar-button-wrapper" id="cleanObstaclesButtonDiv">
					<button type="button" class="button" id="cleanObstaclesButton"> 
						<img src="icons/delete-obstacles.png" class="icon" width="40px" height="40px">
					</button>
					<span class="label" id="cleanObstaclesLabel"> Odstráň prekážky </span>
				</div>
				<div class="sidebar-button-wrapper" id="resetButtonDiv">
					<button type="button" class="button" id="resetButton"> 
						<img src="icons/undo.png" class="icon" width="40px" height="40px">
					</button>
					<span class="label" id="resetLabel"> Začni odznovu </span>
				</div>
			</div>
			<!-- v spodnom sidebare nebudu buttony, ale iba ikony -->
			<div id="sidebar-bottom">
				<span class="label" id="helperLabel"> Pomôcka </span>
				<div class="sidebar-icon-wrapper" id="addWaterIconDiv">
					<img src="icons/left-click.png" class="icon" width="40px" height="40px">
					<span class="label" id="leftClickLabel"> Pridaj vodu </span>
				</div>
				<div class="sidebar-icon-wrapper" id="addObstacleIconDiv">
					<img src="icons/right-click.png" class="icon" width="40px" height="40px">
				 	<span class="label" id="rightClickLabel"> Pridaj prekážku </span>
				</div>
			</div>
		</div>
	</div>
</div>

<!-- CAST 2 - MOD TVORBA, !!! TODO -->
<div id="tvorba-section"> </div>

<!-- Päta stranky -->
<footer>
	<p> Softvér pre vzdelávanie, 1mAIN, 2025/2026
</footer>

<script>
	const modeHra = document.getElementById("mode-hra");
	const modeTvorba = document.getElementById("mode-tvorba");
	const hraSection = document.getElementById("hra-section");
	const tvorbaSection = document.getElementById("tvorba-section");
	const loadButton = document.getElementById("loadButton");
	const fileInput = document.getElementById("fileInput");
	const nextButton = document.getElementById("nextButton");
	const saveButton = document.getElementById("saveButton");
	const runButton = document.getElementById("runButton");
	const nextStepButton = document.getElementById("nextStepButton");
	const cleanButton = document.getElementById("cleanButton");
	const cleanWaterButton = document.getElementById("cleanWaterButton");
	const cleanObstaclesButton = document.getElementById("cleanObstaclesButton");
	const freeButton = document.getElementById("freeButton");
	const saveButtonDiv = document.getElementById("saveButtonDiv");
	const nextButtonDiv = document.getElementById("nextButtonDiv");
	const cleanButtonDiv = document.getElementById("cleanButtonDiv");
	const cleanWaterButtonDiv = document.getElementById("cleanWaterButtonDiv");
	const cleanObstaclesButtonDiv = document.getElementById("cleanObstaclesButtonDiv");
	const loadButtonDiv = document.getElementById("loadButtonDiv");
	const freeButtonDiv = document.getElementById("freeButtonDiv");
	const nextStepButtonDiv = document.getElementById("nextStepButtonDiv");
	const runButtonDiv = document.getElementById("runButtonDiv");
	const resetButton = document.getElementById("resetButton");
	const resetButtonDiv = document.getElementById("resetButtonDiv");
	const loadSolutionButtonDiv = document.getElementById('loadSolutionButtonDiv');
	const loadSolutionButton = document.getElementById('loadSolutionButton');
	const solutionFileInput = document.getElementById('solutionFileInput');
	const openInfo = document.getElementById("openModal");
	const closeInfo = document.getElementById("closeModal");
	const modal = document.getElementById("modal");
	
	//pomocne pole kde si budeme ukladat zadania
	let assignments = [];
	let assignmentsLocal = []; //ulozene zadania v local storage
	//defaultne je volny rozim (ziadne zadanie)
	let assignmentIndex = 0;
	
	let currentAssignment;
	let initialGridSnapshot = null; // snapshot mriezky ako bola nacitana zo zadania pre reset
	
	let gridArray = []; // 2D pole reprezentujuce mriezku
	let waterCells = []; //bunky obsahujuce vodu
	let obstacleCells = []; //bunky obsahujuce prekazku
	let emptyCells = []; //prazdne bunky

	//na zaciatku programu je volny mod, ked moze uzivatel pridavat prekazky a pridavat vodu a skusat, ako funguje algoritmus
	let assignmentType = "free";
	
	// Inicializacia 2D pola na zaklade poctu riadkov a stlpcov
	function initializeGridArray(rows, cols) {
		// 0 znamena prazdne policko v array reprezentacii
		gridArray = Array.from({ length: rows }, () => Array(cols).fill(0));
	}

	// preved stav mriezky do internych poli
	function syncStatesWithGrid() {

		console.log("syncStatesWithGrid - gridArray:", gridArray);
		waterCount = 0;
		waterCells = [];
		obstacleCount = 0;
		obstacleCells = [];
		emptyCount = 0;
		emptyCells = [];
		
		for (let row = 0; row < currentRows; row++) {
			for (let col = 0; col < currentCols; col++) {
				const value = gridArray[row][col];
				const cell = document.getElementById(`cell-${row}-${col}`);
				if (!cell) continue;
				//ak je v bunke voda
				if (value === 1) {
					waterCount = waterCount + 1;
					waterCells.push(cell);
				} 
				//ak je v bunke prekazka
				else if (value === 2) {
					obstacleCount = obstacleCount + 1;
					obstacleCells.push(cell);
				} 
				//ak je bunka prazdna
				else {
					emptyCount = emptyCount + 1;
					emptyCells.push(cell);
				}
			}
		}
	}

	function updateCounter() {
		const counter = document.getElementById("levelCounter");
		
		//ak mam len jedno zadanie, tak napise do div len "Uloha"
		if (assignments.length === 1) {
			counter.innerText = "Úloha";
		}
		else if (assignments.length > 1) {
			//updatni counter vo forme Uloha M/N, kde M je aktualne cislo ulohy a N je pocet vsetkych nacitanych uloh
			counter.innerHTML = "Úloha <span class='details'>" + (assignmentIndex + 1) + "</span>/" + assignments.length;
		}
		else {
			//nic nebolo nacitane
			counter.innerText = "";
		}
	}
	
	function updateProgressTable() {
		const progressTable = document.getElementById("progressTable");
		progressTable.innerHTML = ""; // Clear the table

		const headerRow = document.createElement("tr");
		const typeRow = document.createElement("tr");
		const attemptsRow = document.createElement("tr");
		const statusRow = document.createElement("tr");

		// Add header column
		const headerColumn = document.createElement("th");
		headerColumn.textContent = "#";
		headerRow.appendChild(headerColumn);

		const typeColumn = document.createElement("th");
		typeColumn.textContent = "Typ";
		typeRow.appendChild(typeColumn);

		const attemptsColumn = document.createElement("th");
		attemptsColumn.textContent = "Počet pokusov";
		attemptsRow.appendChild(attemptsColumn);

		const statusColumn = document.createElement("th");
		statusColumn.textContent = "Status";
		statusRow.appendChild(statusColumn);

		assignmentsLocal.forEach((assignment, index) => {
			console.log("assignment", assignment);
			const headerCell = document.createElement("td");
			headerCell.textContent = index + 1;
			if (index === assignmentIndex) {
				headerCell.classList.add("selectedLevel");
			}
			headerRow.appendChild(headerCell);

			const typeCell = document.createElement("td");
			typeCell.textContent = assignment.type;
			if (index === assignmentIndex) {
				typeCell.classList.add("selectedLevel");
			}
			typeRow.appendChild(typeCell);

			const attemptsCell = document.createElement("td");
			console.log("assignment.pokusy:", assignment.pokusy);
			attemptsCell.textContent = assignment.pokusy || 0;
			if (index === assignmentIndex) {
				attemptsCell.classList.add("selectedLevel");
			}
			attemptsRow.appendChild(attemptsCell);

			const statusCell = document.createElement("td");
			console.log("assignment.vyriesene:", assignment.vyriesene);
			statusCell.textContent = assignment.vyriesene ? "✔️" : "❌";
			if (index === assignmentIndex) {
				statusCell.classList.add("selectedLevel");
			}
			statusRow.appendChild(statusCell);
		});

		progressTable.appendChild(headerRow);
		progressTable.appendChild(typeRow);
		progressTable.appendChild(attemptsRow);
		progressTable.appendChild(statusRow);
	}

	function showAssignment(index) {
		console.log("assignmentsLocal:", assignmentsLocal);
		console.log("Current assignment index:", assignmentIndex);
		currentAssignment = assignmentsLocal[index];
		

		assignmentIndex = index;
		
		assignmentType = currentAssignment.type;

		updateProgressTable();
		
		//ak nemam zadanie, tak nic nerob
		if (!currentAssignment) return;

		//uprav pocitadlo currentRows a currentCols podla zadania a vygeneruj podla toho mriezku

		console.log("Current assignment:", currentAssignment);
		currentRows = currentAssignment.grid.rows;
		currentCols = currentAssignment.grid.cols;
		generateGrid(currentRows, currentCols);
		
		let assignmentText = currentAssignment.text;
		
		//formatovanie zadania
		//assignmentText = assignmentText.replaceAll("{{target}}", `<u>${currentAssignment.targetWord}</u>`);
		if (currentAssignment.type === "avoid_cells") {
			document.getElementById("task").innerHTML = generateTextAvoidCells();
		} else if (currentAssignment.type === "fastest_fill") {
			document.getElementById("task").innerHTML = generateTextFastestFill();
		}

		//nacitaj do interneho pola stav mriezky z JSONu (deep copy to avoid accidental mutation)
		gridArray = currentAssignment.grid.gridState.map(row => [...row]);

		//zapamatuj si pociatocny stav mriezky pre reset
		initialGridSnapshot = currentAssignment.grid.gridState.map(row => [...row]);

		//nacitaj do mriezky na stranke stav mriezky z JSONu
		for (let row = 0; row < gridArray.length; row++) {
			for (let col = 0; col < gridArray[row].length; col++) {
				let cellId = `cell-${row}-${col}`;
				let cell = document.getElementById(cellId);
				//ak je bunka prazdna
				if (gridArray[row][col] === 0) {
					cell.className = "cell cellEmpty";
				}
				//ak je v bunke voda
				else if (gridArray[row][col] === 1) {
					cell.className = "cell cellWater";
				}
				//ak je v bunke prekazka
				else if (gridArray[row][col] === 2) {
					cell.className = "cell cellObstacle";
				}
			}
		}
		updateCounter();

		//ked je nacitane zadanie, tak ukaz vsetky buttony v top bare
		showNonFreeButtons();

		//synchronizuj pomocne polia s aktualnym stavom mriezky
		syncStatesWithGrid();

		//ak mame zadanie, tak pridam zobrazim aj reset tlacitko
		resetButtonDiv.style.display = "";

		//bolo nacitanie zadanie, zobraz tlacitko na nahratie riesenia
		loadSolutionButtonDiv.style.display = '';

		//v sidebare zobraz len tie ikony, ktore su relevantne pre dane zadanie (v avoid_cells pridavam len prekazky, teda pomocka je len
		//pre pridavanie prekazok, v fastest_fill pridavam len vodu, teda pomocka je len pre pridavanie vody)
		if (assignmentType === "avoid_cells") {
			cleanButtonDiv.style.display = "none";
			cleanWaterButtonDiv.style.display = "none";
			cleanObstaclesButtonDiv.style.display = "none";
			addWaterIconDiv.style.display = "none";
			addObstacleIconDiv.style.display = "";			
		}
		else if (assignmentType === "fastest_fill") {
			cleanButtonDiv.style.display = "none";
			cleanWaterButtonDiv.style.display = "none";	
			cleanObstaclesButtonDiv.style.display = "none";
			addWaterIconDiv.style.display = "";
			addObstacleIconDiv.style.display = "none";
		}
	}
	
	//funkcia na ukladanie aktualnej session do jsonu 
	function getSessionData() {
		// { type: 'solution', assignmentId: '...', createdAt: 'ISO', placements: { obstacles: [[r,c],...], waterSources: [[r,c],...] }, metrics: {...} }
		//format JSONU riesenia (priklad):
			//"type": "solution",
			//"assignmentId": "assignment-1",
			//"createdAt": "2024-10-01T12:00:00Z",
			//"placements": {
			//    "obstacles": [[0,1],[2,3],...],
			//    "waterSources": [[4,5],[6,7],...]
			//},
			//"metrics": {
			//    "obstacleCount": 10,
			//    "waterCount": 3
			//}

		//ak nie je zadanie, tak neuloz nic
		if (!currentAssignment) return null;

		// ak nebolo zadanie, vytvor aspon nejake ID
		if (currentAssignment && !currentAssignment.id) {
			// vygeneruj unikatne ID pre aktualne zadanie
			currentAssignment.id = generateAssignmentId();
		}

		//objekt, v ktorom si pamatame pole prekazok a zdrojov vody
		const placements = { obstacles: [], waterSources: [] };

		//inicializujeme tento objekt prejdenim mriezky a zapisom do neho
		for (let row = 0; row < currentRows; row++) {
			for (let col = 0; col < currentCols; col++) {
				const value = gridArray[row][col];
				if (value === 2) placements.obstacles.push([row, col]);
				else if (value === 1) placements.waterSources.push([row, col]);
			}
		}

		//dodatocne informacie o rieseni
		const metrics = {
			obstacleCount: placements.obstacles.length,
			waterCount: placements.waterSources.length
		};

		//vrat objekt reprezentujuci riesenie
		return {
			type: 'solution',
			assignmentId: currentAssignment.id,
			createdAt: new Date().toISOString(),
			placements,
			metrics
		};
	}


	//vygeneruj unikatne ID pre aktualne zadanie
	function generateAssignmentId() {
		return crypto.randomUUID();
	}
	
	// metody tykajucesa prepinania rezimov 
	modeHra.onclick = () => {
		modeHra.classList.add("active");
		modeTvorba.classList.remove("active");
		hraSection.classList.remove("hidden");
		tvorbaSection.classList.add("hidden");
		if (assignmentType && assignmentType !== 'free' && assignments && assignments.length > 0) {
			showNonFreeButtons();
		} else {
			hideNonFreeButtons();
		}
	};	
	
	modeTvorba.onclick = () => {
		modeHra.classList.remove("active");
		modeTvorba.classList.add("active");
		hraSection.classList.add("hidden");
		tvorbaSection.classList.remove("hidden");
	};

	//po kliknuti na "Volny rezim"
	freeButton.addEventListener("click", () => setFreeMode());

	//po kliknuti na "Vycisti mriezku" sa vycisti mriezka na obrazovke, aj interne
	cleanButton.addEventListener("click", () => cleanGrid());

	//po kliknuti na "Odstran vodu" sa z mriezky odstrania vsetky bunky s vodou (nahradia s prazdnymi bunkami)
	cleanWaterButton.addEventListener("click", () => cleanWaterGrid());

	//po kliknut na "Odstran prekazky" sa z mriezky odstrania vsetky bunky s prekazkami (nahradia sa prazdnymi bunkami)
	cleanObstaclesButton.addEventListener("click", () => cleanObstaclesGrid());

	//po kliknuti na "Zacni odznovu" sa z mriezky odstrania vsetky bunky v zavislosti od zadania
	resetButton.addEventListener('click', () => {
		if (!currentAssignment || !initialGridSnapshot) {
			//nebolo nacitane zadanie, tak len vycisti mriezku
			cleanGrid();
			return;
		}

		//ak je zadanie "avoid_cells", obnov mriezku do pociatocneho stavu zo zadania (vycistit cele))
		if (assignmentType === 'avoid_cells') {
			cleanGrid();
			// Obnov mriezku do pociatocneho stavu zo zadania
			for (let row = 0; row < currentRows; row++) {
				for (let col = 0; col < currentCols; col++) {
					const cell = document.getElementById(`cell-${row}-${col}`);
					const val = initialGridSnapshot[row][col];
					if (val === 2) {
						gridArray[row][col] = 2;
						cell.className = "cell cellObstacle";
					} else if (val === 1) {
						gridArray[row][col] = 1;
						cell.className = "cell cellWater";
					} else {
						gridArray[row][col] = 0;
						cell.className = "cell cellEmpty";
					}
				}
			}
		} 
		else if (assignmentType === 'fastest_fill') {
			// odstran iba vodu, ktora bola pridana uzivatelom, prekazky nechaj
			for (let row = 0; row < currentRows; row++) {
				for (let col = 0; col < currentCols; col++) {
					const cell = document.getElementById(`cell-${row}-${col}`);
					const val = initialGridSnapshot[row][col];
					if (val === 2) {
						gridArray[row][col] = 2;
						cell.className = "cell cellObstacle";
						
					} else {
						gridArray[row][col] = 0;
						cell.className = "cell cellEmpty";
					}
				}
			}
			syncStatesWithGrid();
		}

		solutionDiv.innerText = "";
		//otvorene na dalsie typy zadani
	});

	
	//po kliknuti na "Nacitaj ulohy" sa otvori fileinput element 
	loadButton.addEventListener("click", () => {
		fileInput.value = "";
		fileInput.click();
	});

	//po kliknuti na "Nacitaj riesenie" sa otvori fileinput element
	loadSolutionButton.addEventListener("click", () => {
		solutionFileInput.value = "";
		solutionFileInput.click();
	});

	//po kliknuti na "Nacitaj riesenie" sa nacita JSON subor a aplikuje sa na mriezku
	solutionFileInput.addEventListener("change", (event) => {
		const file = event.target.files && event.target.files[0];

		//ak nie je subor, tak nic nerob
		if (!file) return;
		const reader = new FileReader();
		reader.onload = () => {
			try {
				const solution = JSON.parse(reader.result);

				//podmienky - riesenie ma byt typu "solution" a zadania a solution sa maju zhodovat na assignmentId
				if (solution.type && solution.type !== "solution") {
					alert('Nacitany subor je typu "' + solution.type + '" (ma byt "solution").');
					return;
				}
				const solutionId = solution.assignmentId;
				if (solutionId && currentAssignment.id && solutionId !== currentAssignment.id) {
					alert('ID zadania v rieseni neodpoveda ID aktualneho zadania.');
					return;
				}

				// ak je zadanie "fastest_fill", skontroluj, ci sa prekazky v rieseni zhoduju s prekazkami v aktualnom zadani
				if (assignmentType === 'fastest_fill') {
					const solutionObstacles = (solution.placements && Array.isArray(solution.placements.obstacles)) ? solution.placements.obstacles : null;
					// compute assignment obstacles
					const assignmentObstacles = [];
					//kontrola, ci je definovany aktualny assignment a ci ma mriezku
					if (currentAssignment && currentAssignment.grid && Array.isArray(currentAssignment.grid.gridState)) {
						for (let row = 0; row < currentAssignment.grid.gridState.length; row++) {
							for (let col = 0; col < currentAssignment.grid.gridState[row].length; col++) {
								if (currentAssignment.grid.gridState[row][col] === 2) assignmentObstacles.push([row, col]);
							}
						}
					}

					//porovnanie dvoch poli suradnic prekazok (ignoruj poradie) :)
					function coordKey(a){ return `${a[0]}_${a[1]}` }
					const assignmentSet = new Set(assignmentObstacles.map(coordKey));
					let match = true;
					if (!solutionObstacles) match = false;
					else {
						const solutionSet = new Set(solutionObstacles.map(coordKey));
						if (solutionSet.size !== assignmentSet.size) match = false;
						else {
							for (const k of assignmentSet) if (!solutionSet.has(k)) { match = false; break; }
						}
					}
					if (!match) {
						alert("Nemozem nacitat riesenie: prekazky v rieseni sa nezhoduju s prekazkami v aktualnom zadani.");
						return;
					}
				}
				//aplikuj riesenie na mriezku
				if (assignmentType === 'avoid_cells') {
					//ak je definovane pole prekazok, aplikuj ich na mriezku
					const obstacles = solution.placements && Array.isArray(solution.placements.obstacles) ? solution.placements.obstacles : null;
					if (!Array.isArray(obstacles)) {
						alert('V rieseni chybaju prekazky.');
						return;
					}
					//aplikuj na mriezku prekazky z riesenia
					applyObstaclesFromSolution(obstacles);
					alert('Prekazky boli vlozene do mriezky podla riesenia.');
					syncStatesWithGrid();
				} 
				else if (assignmentType === 'fastest_fill') {
					//ak je definovane pole zdrojov vody, aplikuj ich na mriezku (v tomto pripade len jeden zdroj vody)
					const sources = solution.placements && Array.isArray(solution.placements.waterSources) ? solution.placements.waterSources : null;
					if (!Array.isArray(sources) || sources.length === 0) {
						alert('V rieseni chyba zdroj vody.');
						return;
					}
					//v fastest_fill je povoleny len jeden zdroj vody
					const [row, col] = sources[0];
					applyWaterSourceFromSolution(row, col);
					syncStatesWithGrid();
					alert('Zdroj vody bol vlozeny do mriezky podla riesenia.');
				}
			} catch (error) {
				console.error(error);
				alert('Chyba pri nacitani riesenia: ' + error.message);
			}
		};
		reader.readAsText(file);
	});


	//funkcia, ktora do mriezky prida prekazky na suradniciach z pola obstacles = [[r1,c1],[r2,c2],...]
	function applyObstaclesFromSolution(obstacles) {
		//odstran vsetky predosle prekazky
		for (let row = 0; row < currentRows; row++) {
			for (let col = 0; col < currentCols; col++) {
				if (gridArray[row][col] === 2) {
					gridArray[row][col] = 0;
					const cell = document.getElementById(`cell-${row}-${col}`);
					if (cell) cell.className = 'cell cellEmpty';
				}
			}
		}

		//aplikuj nove prekazky z argumentu
		for (let i = 0; i < obstacles.length; i++) {
			const coord = obstacles[i];
			const [row, col] = coord;
			//skontroluj, ci su suradnice v rozsahu mriezky
			if (row < 0 || row >= currentRows || col < 0 || col >= currentCols) continue;
			//pridaj
			gridArray[row][col] = 2;
			const cell = document.getElementById(`cell-${row}-${col}`);
			if (cell) cell.className = 'cell cellObstacle';
		}

		//synchronizuj pomocne polia s aktualnym stavom mriezky
		syncStatesWithGrid();
	}

	//funkcia, ktora do mriezky prida jeden zroj vody na suradniciach [cellRow, cellCol]
	function applyWaterSourceFromSolution(cellRow, cellCol) {
		//odstran vsetku predoslu vodu
		for (let i = 0; i < currentRows * currentCols; i++) {
			let row = Math.floor(i/currentCols);
			let col = i % currentCols;
			if (gridArray[row][col] === 1) {
				gridArray[row][col] = 0;
				const cell = document.getElementById(`cell-${row}-${col}`);
				if (cell) cell.className = 'cell cellEmpty';
			}
		}


		//skontroluj, ci su suradnice v rozsahu mriezky
		if (cellRow < 0 || cellRow >= currentRows || cellCol < 0 || cellCol >= currentCols) return;
		//pridaj vodu
		gridArray[cellRow][cellCol] = 1;
		const cell = document.getElementById(`cell-${cellRow}-${cellCol}`);
		if (cell) cell.className = 'cell cellWater';

		//synchronizuj interne polia
		syncStatesWithGrid();
	}

	//po kliknuti na "Spusti jeden krok" sa vykona jeden krok FloodFill algoritmu
	nextStepButton.addEventListener("click", () => nextStep());

	//po kliknuti na "Spusti program" sa zacne vykonavat algoritmus FloodFill a automaticky sa zmeni na stop button
	runButton.addEventListener("click", () => startSimulation());
	
	//po kliknuti na "Uloz riesenie" sa stiahne subor s nazvom UlohaN-riesenie.json, kde N je cislo ulohy
	saveButton.addEventListener("click", () => {
		//ziskaj udaje o aktualnej session (getSessionData() vytvori assignmentId, ak chybalo)
		const data = getSessionData();

		//ak nie je ziadne aktualne zadanie/solution, nedovolime ulozit 'null'
		if (!data) {
			alert('Nie je načítané žiadne zadanie alebo riešenie na uloženie.');
			return;
		}

		//preved do json formatu stringu
		const jsonString = JSON.stringify(data, null, 2);
		//prevod na json blob
		const blob = new Blob([jsonString], { type: "application/json" });

		//stiahnutie suboru: preferuj assignmentId obsiahnute v ulozenych datach
		const link = document.createElement("a");
		const url = URL.createObjectURL(blob);
		link.href = url;
		link.download = `Uloha${assignmentIndex + 1}-riesenie.json`;

		//pridaj do dokumentu pre lepsiu kompatibilitu (niektore prehliadace vyzaduju to)
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);

		URL.revokeObjectURL(url);
	});
	
	//po kliknuti "Dalsia uloha" sa prejde na dalsie zadanie
	nextButton.addEventListener("click", () => {
		if (assignments.length > 1) {
			saveCurrentStateToLocalStorage(assignmentIndex);
			assignmentIndex = (assignmentIndex + 1) % assignments.length;
			// Vyprázdni solution grid
			document.getElementById("solutionDiv").innerHTML = "";

			// Skontroluj, či už bolo zadanie riešené
			if (assignmentsLocal[assignmentIndex]) {
				const assignment = assignmentsLocal[assignmentIndex];
				if (assignment.vyriesene) {
					document.getElementById("solutionDiv").innerHTML = "<span class='correct'>Zadanie už bolo vyriešené správne.</span>";
				} else if (assignment.pokusy > 0) {

					document.getElementById("solutionDiv").innerHTML = "<span class='incorrect'>Zadanie ešte nebolo vyriešené správne.</span>";
				} else {
					document.getElementById("solutionDiv").innerHTML = "<span class='incorrect'>Zadanie ešte nebolo riešené.</span>";
				}
			}
			//cleanGrid();
			
			showAssignment(assignmentIndex);
		}
	});
	
	function saveCurrentStateToLocalStorage(index) {
		if (!currentAssignment) return;
		//uloz aktualny stav mriezky do aktualneho zadania
		assignmentsLocal[index].grid.gridState = gridArray.map(row => [...row]);
		
	}

	fileInput.addEventListener("change", (event) => {
	
		//vybrane jsonFiles
		const files = event.target.files;
		if (!files || files.length === 0) return;

		const promises = Array.from(files).map(file => {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => {
					try {
						const json = JSON.parse(reader.result);
						resolve({ json, fileName: file.name });
					} catch (error) {
						reject(error);
					}
				};
				reader.onerror = () => reject(reader.error);
				reader.readAsText(file);
			});
		});

		// pockam, kym su vsetky jsony precitane
		Promise.all(promises)
			//potom uloz nacitane subory do assignments pola
			.then(results => {
				assignments = [];
				results.forEach(({ json, fileName }) => {
					if (!json.id) json.id = generateAssignmentId();
					assignments.push(json);
					console.log(`Nacitany subor ${fileName}:`, json);
				});
				//vycisti grid, ak je na nom voda alebo prekazky a ukaz prve zadanie
				cleanGrid();
				
				assignmentsLocal = assignments;
				assignmentsLocal.forEach(assignment => {
					assignment.vyriesene = 0;
					assignment.pokusy = 0;
				});

				console.log("nnNacitane zadania:", assignments);
				console.log("nnassignmentsLocal:", assignmentsLocal);
				showAssignment(0);
				updateProgressTable();
		})
		.catch(error => {
			console.error("Chyba pri nacitani json suborov:", error);
		});
	});
	
	// listenery na popup - ak sa klikne na info Button, tak sa otvori Popup
	openInfo.addEventListener("click", () => {
		modal.classList.add("open");
	});
	
	// ak sa klikne na X button v popupe, tak sa zatvori 
	closeInfo.addEventListener("click", () => {
		modal.classList.remove("open");
	});
	
	// QoL doplnky - ESC tlacitko zatvori popup okno
	document.addEventListener("keydown", e => {
		if(e.key === "Escape") modal.classList.remove("open");
	});
	
	// dizajn - oble okraje gridu
	function setRoundCorners(rows, cols) {
		const cells = document.querySelectorAll("#grid .cell");
		//ak nie su ziadne bunky, tak nic nerob
		if (!cells.length) return;
		
		let topLeft = cells[0];
		topLeft.style.borderTopLeftRadius = "10px";
		let topRight = cells[cols - 1]; 
		topRight.style.borderTopRightRadius = "10px";
		let bottomLeft = cells[cells.length - cols];
		bottomLeft.style.borderBottomLeftRadius = "10px";
		let bottomRight = cells[cells.length - 1];
		bottomRight.style.borderBottomRightRadius = "10px";
	}
	
	//dizajn - hrubsi okraj gridu
	function setOuterBorders(rows, cols) {
		const cells = document.querySelectorAll("#grid .cell");
		//ak nie su ziadne bunky, tak nic nerob
		if (!cells.length) return;
		
		cells.forEach((cell, index) => {
			const row = Math.floor(index / cols);
			const col = index % cols;
			
			if (row === 0) {
				cell.style.borderTopWidth = "3px";
			}
			if (row === rows - 1) {
				cell.style.borderBottomWidth = "3px";
			}
			if (col === 0) {
				cell.style.borderLeftWidth = "3px";
			}
			if (col === cols - 1) {
				cell.style.borderRightWidth = "3px";
			}
		});
	}
	
	let currentRows = 0;
	let currentCols = 0;

	//funkcia na vycistenie gridu - prenastavenie vsetkych buniek mriezky na "empty"
	function cleanGrid() {
		for (let i = 0; i < currentRows * currentCols; i++) {
			//najdenie prislusnej bunky
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			//vyprazdnenie nastavenim prislusnych classov
			cell.className = "cell cellEmpty";
		}
		
		//vycistenie mriezky aj interne (v 2D poli)
		initializeGridArray(currentRows, currentCols);
		//synchronizacia pomocnych poli s aktualnym stavom mriezky
		syncStatesWithGrid();
	}

	function cleanWaterGrid() {

		//zresetovanie prislusnych premennych drziacich info o vode
		waterCells = [];
		waterCount = 0;

		for (let i = 0; i < currentRows * currentCols; i++) {
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			if (cell.classList.contains("cellWater")) {
				//vyprazdnenie nastavenim prislusnych classov
				cell.className = "cell cellEmpty";
				gridArray[cellRow][cellCol] = 0;
			}
		}
		// rebuild canonical auxiliary trackers
		syncStatesWithGrid();
	}

	function cleanObstaclesGrid() {

		//zresetovanie prislusnych premennych drziacich info o prekazkach
		obstacleCells = [];
		obstacleCount = 0;
		for (let i = 0; i < currentRows * currentCols; i++) {
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			let cellId = `cell-${cellRow}-${cellCol}`;
			let cell = document.getElementById(cellId);
			if (cell.classList.contains("cellObstacle")) {
				//vyprazdnenie nastavenim prislusnych classov
				cell.className = "cell cellEmpty";
				gridArray[cellRow][cellCol] = 0;
			}
		}
		//synchronizacia pomocnych poli s aktualnym stavom mriezky
		syncStatesWithGrid();
	}

	function setFreeMode() {
		//uchovaj si aktualny assignment type
		assignmentType = "free";
		//pri prepnuti na volny rezim sa vymazu zadania
		assignments = [];
		assignmentIndex = 0;
		//vycisti grid
		cleanGrid();
		//prenastav divs v task-div
		document.getElementById("levelCounter").innerHTML = "<p> Voľný režim </p>";
		document.getElementById("zadanieHeader").innerText = "";
		document.getElementById("task").innerHTML = "<p> Aktuálne sa nachádzate vo voľnom režime, v ktorom môžete do mriežky pridávať <u>prekážky</u> a <u>zdroje vody</u>. Pre načítanie zadaní úloh kliknite na tlačítko <b>Načítaj úlohy</b>.</p>";

		// schovaj buttony, ktore su v tomto rezime nepotrebne
		hideNonFreeButtons();
		syncStatesWithGrid();
	}

	function hideNonFreeButtons() {
		// v volnom rezime chceme len: Nacitaj, Jeden krok, Spusti/Zastav
		const toHide = [freeButtonDiv, loadSolutionButtonDiv, saveButtonDiv, nextButtonDiv, resetButtonDiv];

		for (let i = 0; i < toHide.length; i++) {
			if (toHide[i]) toHide[i].style.display = "none";
		}

		// buttony ktore su v tomto rezime potrebne
		loadButtonDiv.style.display = '';
		nextStepButtonDiv.style.display = '';
		runButtonDiv.style.display = '';
		cleanButtonDiv.style.display = '';
		cleanWaterButtonDiv.style.display = '';
		cleanObstaclesButtonDiv.style.display = '';
		addWaterIconDiv.style.display = '';
		addObstacleIconDiv.style.display = '';

	}

	function showNonFreeButtons() {
		const toShow = [freeButtonDiv, saveButtonDiv, nextButtonDiv, resetButtonDiv];
		for (let i = 0; i < toShow.length; i++) {
			if (toShow[i]) toShow[i].style.display = "";
		}
	}

	let waterCount = 0;
	let emptyCount = 0;


	//pridanie vody do bunky [cellRow, cellCol], respektive jej odstranenie, ak v nej voda uz je
	function handleLeftClick(cell, cellRow, cellCol) {

		//pri zadani typu "avoid_cells" sa nemoze pridavat voda
		if (assignmentType === "avoid_cells") return;

		//ak uz je v bunke voda, tak vyprazdni bunku
		if (gridArray[cellRow][cellCol] === 1) {
			waterCount = waterCount - 1;
			gridArray[cellRow][cellCol] = 0;
			cell.className = "cell cellEmpty";
			// remove from waterCells
			let index = waterCells.indexOf(cell);
			if (index != -1) waterCells.splice(index, 1);
			// add to empty trackers
			emptyCount = emptyCount + 1;
			emptyCells.push(cell);
		}
		//inak tam pridaj vodu
		else {
			//pri zadani typu "fastest_fill" je pocet policok vody obmedzeny na jedno
			if (assignmentType === "fastest_fill" && (waterCount > 0 || cell.classList.contains("cellObstacle"))) return;
			waterCount = waterCount + 1;
			gridArray[cellRow][cellCol] = 1;
			cell.className = "cell cellWater";
			waterCells.push(cell);
			// remove from empty trackers if present
			//emptyCount = emptyCount - 1;
			//let index = emptyCells.indexOf(cell);
			//if (index != -1) emptyCells.splice(index, 1);

		}
		syncStatesWithGrid();
	}

	let obstacleCount = 0;

	//pridanie prekazky do bunky [cellRow, cellCol], respektive jej odstranenie, ak v nej prekazka uz je
	function handleRightClick(cell, cellRow, cellCol) {

		//pri zadani typu "fastest_fill" sa do mriezky nepridavaju prekazky
		if (assignmentType === "fastest_fill") return;

		//ak uz je v bunke prekazka, tak vyprazdni bunku
		if (gridArray[cellRow][cellCol] === 2) {
			obstacleCount = obstacleCount - 1;
			gridArray[cellRow][cellCol] = 0;
			cell.className = "cell cellEmpty";
			// remove from obstacleCells
			let index = obstacleCells.indexOf(cell);
			if (index != -1) obstacleCells.splice(index, 1);
			// add to empty trackers
			emptyCount = emptyCount + 1;
			emptyCells.push(cell);
		}
		//inak tam pridaj prekazku
		else {
			//pri zadani typu "avoid_cells" je obmedzeny pocet prekazok v mriezke na .goal.maxNumOfObstacles
			if (assignmentType === "avoid_cells" && obstacleCount > currentAssignment.goal.maxNumOfObstacles - 1) return;
			obstacleCount = obstacleCount + 1;
			gridArray[cellRow][cellCol] = 2;
			cell.className = "cell cellObstacle";
			obstacleCells.push(cell);
			// remove from empty trackers if present
			//emptyCount = emptyCount - 1;
			//let index = emptyCells.indexOf(cell);
			//if (index != -1) emptyCells.splice(index, 1);
		}
		syncStatesWithGrid();
	}
	
	const grid = document.getElementById("grid");

	//funkcia na vytvorenie mriezky rozmerov [riadky, stlpce], sizePolicka je velkost jednej bunky/stvorceka
	//zaklad 8x8
	function generateGrid(rows, cols) {
		
		currentRows = rows;
		currentCols = cols;
	
		initializeGridArray(currentRows, currentCols);

		const grid = document.getElementById("grid");
		grid.innerHTML = "";
		
		//velkost mriezky - aby sa to zmestilo na obrazovku bez scrollovania
		const maxGridSize = Math.min(window.innerWidth, window.innerHeight) * 0.5;
		
		//dynamicky zmenit velkost bunky v zavislosti od poctu riadkov/stlpcov
		let cellSize = Math.floor(maxGridSize/currentRows);
		//najvacsia velkost bunky
		if (cellSize > 80) cellSize = 80;
		
		// nastavenie poctu stlpcov a velkost bunky
		grid.style.gridTemplateColumns = "repeat(" + currentCols + ", " + cellSize + "px)";
  
		// nastavenie poctu riadkov a velkost bunky
		grid.style.gridTemplateRows = "repeat(" + currentRows + ", " + cellSize + "px)";
		
		console.log(currentRows);
		console.log(currentCols);
		//vytvorenie buniek
		for (let i = 0; i < currentRows * currentCols; i++) {
			let cell = document.createElement("div");
			cell.classList.add("cell", "cellEmpty"); // defaultne je bunka prazdna, pridanie class="cellEmpty" (two-class approach)
			let cellRow = Math.floor(i/currentCols);
			let cellCol = i % currentCols;
			cell.id = `cell-${cellRow}-${cellCol}`; // id v tvare cell-row-col
			cell.addEventListener("click", () => handleLeftClick(cell, cellRow, cellCol));
			cell.addEventListener("contextmenu", (e) => {
				e.preventDefault();
				handleRightClick(cell, cellRow, cellCol);
			});
			grid.appendChild(cell);
		}
		
		//funkcia na oble okraje mriezky
		setRoundCorners(currentRows, currentCols);
		
		//funkcia na hrubsie vonkajsie okraje mriezky
		setOuterBorders(currentRows, currentCols);

		//defaultne v volnom rezime
		hideNonFreeButtons();

		//synchronizacia pomocnych poli s aktualnym stavom mriezky
		console.log("Generating grid and syncing states:");
		syncStatesWithGrid();
		
	}
	
	//ak nie je nacitane zadanie, vykresli defaultny grid 8x8
	if (assignmentType === "free" || assignmentType === null) generateGrid(8,8);
	else generateGrid(currentAssignment.grid.rows, currentAssignment.grid.cols);


	//window.addEventListener("resize", () => generateGrid());

	function nextStep() {
		//kopia mriezky, aby nova voda neovplyvnila fill
		stepsCounter++;
		let newGridArray = gridArray.map(arr => [...arr]);

		//boolean trackujuci zmenu v mriezke
		let changed = false;
		console.log("assignmentType:", assignmentType);
		// Prejdi všetkými krajnými políčkami, ktoré sú == 0
		if (assignmentType == 'avoid_cells') {
			for (let row = 0; row < gridArray.length; row++) {
				for (let col = 0; col < gridArray[row].length; col++) {
					// Skontroluj, či je políčko na kraji a zároveň prázdne (== 0)
					if ((row === 0 || row === gridArray.length - 1 || col === 0 || col === gridArray[row].length - 1) && gridArray[row][col] === 0) {
						// Pridaj do tej bunky vodu (1)
						newGridArray[row][col] = 1;
						// Nastala zmena v mriezke
						changed = true;
						// Prenastav div bunky aj na stránke
						const newWaterCell = document.getElementById(`cell-${row}-${col}`);
						newWaterCell.classList.remove("cellEmpty");
						newWaterCell.classList.add("cellWater");
						// Iba ak ešte nie je v zozname waterCells (ochrana proti duplikátom)
						if (!waterCells.includes(newWaterCell)) {
							waterCount = waterCount + 1;
							waterCells.push(newWaterCell);
							emptyCount = emptyCount - 1;
							let index = emptyCells.indexOf(newWaterCell);
							if (index != -1) emptyCells.splice(index, 1);
						}
					}
				}
			}
		}
		// floodfill algoritmus
		for (let row = 0; row < gridArray.length; row++) {
			for (let col = 0; col < gridArray[row].length; col++) {
				//ak je v bunke voda, tak sa rozsiruj do susedov, voda = 1
				if (gridArray[row][col] === 1) {
					//susedia bunky cell = [row][col]
					const neighbours = [
						[row - 1, col], //horny sused
						[row + 1, col], //dolny sused
						[row, col - 1], //lavy sused
						[row, col + 1] //pravy sused
					];
					
					neighbours.forEach(([nRow, nCol]) => {
						//ak je riadok suseda v rozsahu mriezky
						if (nRow >= 0 && nRow < gridArray.length 
						// a zaroven ak je stlpec suseda v rozsahu mriezky
						&& nCol >= 0 && nCol < gridArray[row].length
						//a zaroven ak je bunka [nRow][nCol] prazdna v povodnej mriezke (0)
						&& gridArray[nRow][nCol] === 0
						// a zaroven nebola este oznacena ako nova voda v tejto iteracii
						&& newGridArray[nRow][nCol] === 0) {
							//pridaj do tej bunky vodu (1)
							newGridArray[nRow][nCol] = 1;
							//nastala zmena v mriezke
							changed = true;
							//prenastav div bunky aj na stranke
							const newWaterCell = document.getElementById(`cell-${nRow}-${nCol}`);
							newWaterCell.classList.remove("cellEmpty");
							newWaterCell.classList.add("cellWater");
							// iba ak este nie je v zozname waterCells (ochrana proti duplikatom)
							if (!waterCells.includes(newWaterCell)) {
								waterCount = waterCount + 1;
								waterCells.push(newWaterCell);
								emptyCount = emptyCount - 1;
								let index = emptyCells.indexOf(newWaterCell);
								if (index != -1) emptyCells.splice(index, 1);
							}
						}
					});
				}
			}
		}

		//prekopiruj novu mriezku do globalneho pola pre mriezku
		gridArray = newGridArray;

		//ak sa nic do mriezky nepridalo, tak ukonci simulaciu
		if (!changed) {
			stopSimulation();
			// verifikuj vysledok 
			verifyAfterSimulation();
		}
	}
	
	//window.addEventListener("resize", () => generateGrid());

	//nastavenie stavu buttonu (toggle = true-enabled/false-disabled)
	function setButtonState(buttonId, toggle) {
		if (!buttonId) return;
		const button = document.getElementById(buttonId);
		//buttony mozu byt v button-wrapper alebo v sidebar-button-wrapper (column vs row rozlozenie button-label)
		let wrapper = button.closest(".button-wrapper");
		if (wrapper == null) {
			wrapper = button.closest(".sidebar-button-wrapper");
		}

		//ak je toggle = true, tak enable button-label
		if (toggle) {
			button.disabled = false;
			wrapper.classList.remove("disabled");
		//inak disable
		} else {
    		button.disabled = true;
			wrapper.classList.add("disabled");
 		}
	}

	let simulationInterval;
	let stepsCounter = -1;

	//funkcia na spustenie algoritmu FloodFillu
	function startSimulation() {

		if (assignmentType === "fastest_fill") {
			const allowedSources = currentAssignment.goal.allowedSources;
			if (waterCount > allowedSources) {
				alert(`Počet vodných zdrojov (${waterCount}) prekročil povolený limit (${allowedSources}).\nStlačte tlačidlo začni odznova.`);
				return;
			}
		}
		//vypni vsetky zvysne buttony, ked prebieha algoritmus
		stepsCounter = -1;
		setButtonState("freeButton", false);
		setButtonState("loadButton", false);
		setButtonState("loadSolutionButton", false);
		setButtonState("nextStepButton", false);
		setButtonState("resetButton", false);
		setButtonState("cleanButton", false);
		setButtonState("cleanWaterButton", false);
		setButtonState("cleanObstaclesButton", false);
		setButtonState("saveButton", false);
		setButtonState("nextButton", false);

		//zmen run button na stop button
		document.getElementById("runButtonDiv").innerHTML = '<button type="button" class="button" id="stopButton" onclick="stopSimulation()"><img src="icons/stop.png" class="icon" width="50px" height="50px"></button><span class="label" id="stopLabel"> Stopni program </span>';

		//kazdych 0.5sekundy sa vykona jeden krok floodfill algoritmu
		simulationInterval = setInterval(() => {
			nextStep();
		}, 500);
		
	}

	//funkcia na zastavenie algoritmu FloodFillu
	function stopSimulation() {
		//znovu zapne vsetky zvysne buttony, pretoze sa stopol algoritmus 
		setButtonState("freeButton", true);
		setButtonState("loadButton", true);
		setButtonState("loadSolutionButton", true);
		setButtonState("nextStepButton", true);
		setButtonState("resetButton", true);
		setButtonState("cleanButton", true);
		setButtonState("cleanWaterButton", true);
		setButtonState("cleanObstaclesButton", true);
		setButtonState("saveButton", true);
		setButtonState("nextButton", true);

		//zmen stop button na run button
		document.getElementById("runButtonDiv").innerHTML = '<button type="button" class="button" id="runButton" onclick="startSimulation()"><img src="icons/play-button.png" class="icon" width="50px" height="50px"></button><span class="label" id="runLabel"> Spusti program </span>';
		if (simulationInterval) {
			clearInterval(simulationInterval);
			simulationInterval = null;
		}
		if (assignmentsLocal[assignmentIndex] && assignmentsLocal[assignmentIndex].vyriesene === 0) {
			assignmentsLocal[assignmentIndex].pokusy = (assignmentsLocal[assignmentIndex].pokusy || 0) + 1;
		}
		updateProgressTable();
	}

	// kontrola riesenia po ukonceni simulacie
	function verifyAfterSimulation() {
		if (!currentAssignment) return;
		syncStatesWithGrid();

		//ak je zadanie "avoid_cells" tak skontroluj, ci je pocet suchych policok numOfEmptyCells rovnaky ako v cieli a ci je pocet prekazok vacsi ako maxNumOfObstacles
		if (currentAssignment.type === "avoid_cells") {
			const numEmptyCells = currentAssignment.goal && currentAssignment.goal.numOfEmptyCells;
			const maxObstacles = currentAssignment.goal && currentAssignment.goal.maxNumOfObstacles;
			//ak pocet suchych buniek nie je dobre definovany, tak nic nerob
			if (typeof numEmptyCells !== "number") return;

			//celkovy pocet buniek v mriezke
			const totalCells = currentRows * currentCols;
			//pocet suchych buniek zalozeny na internom counteri
			const dry = totalCells - waterCount - obstacleCount;
			//ak sa rovna ciel s tym, co mame tak ok = true, inak false
			let ok = (dry === numEmptyCells);

			//ak je maxObstacles definovane, tak ok je true len ak je splnena aj tato podmienka (interne pocitane prekazky su vacsie ako minimum)
			if (typeof maxObstacles === "number") ok = ok && (obstacleCount >= maxObstacles);

			document.getElementById("solutionDiv").innerHTML = ok ? "<span class='correct'>Riešenie je správne.</span>" : `<span class='incorrect'>Riešenie nie je správne.</span><br><span class='details'>Suchých políčok: <strong  style='font-size: 24px;'>${dry}</strong>/${numEmptyCells}.<br>Prekážok: <strong style='font-size: 24px;'>${obstacleCount}</strong>${typeof maxObstacles==="number" ? "/" + maxObstacles + "" : ""}.</span>`;
			if (ok) {
				assignmentsLocal[assignmentIndex].vyriesene = 1;
				updateProgressTable();
			}
		}

		if (currentAssignment.type === "fastest_fill") {
			//v fastest_fill je riesenie spravne, ak je vsetka voda rozlita (teda v mriezke nie je ziadna prazdna bunka)
			let ok = (waterCount + obstacleCount === currentRows * currentCols);
			// TODO: compute and compare number of steps if the assignment specifies a target step count
			//if (currentAssignment.goal && typeof currentAssignment.goal.maxSteps === "number") {
				if (ok && stepsCounter <= currentAssignment.goal.maxSteps) {
					document.getElementById("solutionDiv").innerHTML = "<span class='correct'>Riešenie je správne.</span>";
					assignmentsLocal[assignmentIndex].vyriesene = 1;
					updateProgressTable();
				} else if (ok && stepsCounter > currentAssignment.goal.maxSteps) {
					document.getElementById("solutionDiv").innerHTML = `<span class='incorrect'>Riešenie je správne, ale počet krokov bol prekročený.</span><br><span class='details'>Počet krokov: <strong style='font-size: 24px;'>${stepsCounter}</strong>/${currentAssignment.goal.maxSteps}.</span>`;
				} else {
					document.getElementById("solutionDiv").innerHTML = "<span class='incorrect'>Riešenie nie je správne.</span>";
				}
		}
	}

	function generateTextAvoidCells() {
		if (!currentAssignment) return "";
		let text = `Vašim cieľom je pridať prekážky do mriežky tak, aby voda nezaplavila presne <span class="details" style="font-size: 24px;">${currentAssignment.goal.numOfEmptyCells}</span> ${currentAssignment.goal.numOfEmptyCells === 1 ? 'suché políčko' : (currentAssignment.goal.numOfEmptyCells >= 2 && currentAssignment.goal.numOfEmptyCells <= 4 ? 'suché políčka' : 'suchých políčok')}. Použite maximálne <span class="details" style="font-size: 24px;">${currentAssignment.goal.maxNumOfObstacles}</span> ${currentAssignment.goal.maxNumOfObstacles === 1 ? 'prekážku' : (currentAssignment.goal.maxNumOfObstacles >= 2 && currentAssignment.goal.maxNumOfObstacles <= 4 ? 'prekážky' : 'prekážok')}.\n\n`;
		
		//Minimálny počet prekážok je ${currentAssignment.goal.minNumOfObstacles}.\n\n`;
		/*text += "Pravidlá:\n";
		text += "- Prekážky sa pridávajú pravým kliknutím na bunku.\n";
		text += "- Počet prekážok musí byť minimálne " + currentAssignment.goal.minNumOfObstacles + ".\n";
		text += "- Počet suchých políčok musí byť presne " + currentAssignment.goal.numOfEmptyCells + ".\n";
		text += "- Voda sa automaticky rozleje z okrajových políčok.\n";
		text += "- Môžete spustiť simuláciu, ktorá ukáže, ako sa voda rozleje.\n";
		text += "- Po skončení simulácie sa zobrazí, či je riešenie správne.\n";*/
		return text;
	}

	function generateTextFastestFill() {
		if (!currentAssignment) return "";
		let allowedSources = currentAssignment.goal.allowedSources; 
		let sourceText = allowedSources === 1 ? 'zdroj vody' : (allowedSources >= 2 && allowedSources <= 4 ? 'zdroje vody' : 'zdrojov vody');
		let text = `Vašim cieľom je pridať <span class="details">${allowedSources}</span> ${sourceText} do mriežky tak, aby sa voda rozliala do všetkých políčok čo najrýchlejšie.</span><br>`;
		text += `Povolený počet krokov: <span class="details" style="font-size: 24px;">${currentAssignment.goal.maxSteps}</span>.\n`;
		/*text += "Pravidlá:\n";
		text += "- Zdroj vody sa pridáva ľavým kliknutím na bunku.\n";
		text += "- Môžete pridať len jeden zdroj vody.\n";
		text += "- Voda sa rozleje zo zdroja do všetkých susedných políčok.\n";
		text += "- Môžete spustiť simuláciu, ktorá ukáže, ako sa voda rozleje.\n";
		text += "- Po skončení simulácie sa zobrazí, či je riešenie správne.\n";*/
		return text;
	}
</script>
</body>
</html>
